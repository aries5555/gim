// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connect_server.proto

#ifndef PROTOBUF_connect_5fserver_2eproto__INCLUDED
#define PROTOBUF_connect_5fserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "pair.pb.h"
// @@protoc_insertion_point(includes)

namespace gim {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_connect_5fserver_2eproto();
void protobuf_AssignDesc_connect_5fserver_2eproto();
void protobuf_ShutdownFile_connect_5fserver_2eproto();

class LoginRequest;
class LoginResponse;
class Address;
class RedirectResponse;
class ServiceRequest;
class ServiceResponse;
class KickCliRequest;

// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // repeated .gim.Pair kvs = 5;
  inline int kvs_size() const;
  inline void clear_kvs();
  static const int kKvsFieldNumber = 5;
  inline const ::gim::Pair& kvs(int index) const;
  inline ::gim::Pair* mutable_kvs(int index);
  inline ::gim::Pair* add_kvs();
  inline const ::google::protobuf::RepeatedPtrField< ::gim::Pair >&
      kvs() const;
  inline ::google::protobuf::RepeatedPtrField< ::gim::Pair >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:gim.LoginRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* version_;
  ::std::string* token_;
  ::google::protobuf::RepeatedPtrField< ::gim::Pair > kvs_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string sessid = 2;
  inline bool has_sessid() const;
  inline void clear_sessid();
  static const int kSessidFieldNumber = 2;
  inline const ::std::string& sessid() const;
  inline void set_sessid(const ::std::string& value);
  inline void set_sessid(const char* value);
  inline void set_sessid(const char* value, size_t size);
  inline ::std::string* mutable_sessid();
  inline ::std::string* release_sessid();
  inline void set_allocated_sessid(::std::string* sessid);

  // optional int64 server_time = 3;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 3;
  inline ::google::protobuf::int64 server_time() const;
  inline void set_server_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:gim.LoginResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_sessid();
  inline void clear_has_sessid();
  inline void set_has_server_time();
  inline void clear_has_server_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sessid_;
  ::google::protobuf::int64 server_time_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gim.Address)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class RedirectResponse : public ::google::protobuf::Message {
 public:
  RedirectResponse();
  virtual ~RedirectResponse();

  RedirectResponse(const RedirectResponse& from);

  inline RedirectResponse& operator=(const RedirectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedirectResponse& default_instance();

  void Swap(RedirectResponse* other);

  // implements Message ----------------------------------------------

  RedirectResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RedirectResponse& from);
  void MergeFrom(const RedirectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // repeated .gim.Address addrs = 2;
  inline int addrs_size() const;
  inline void clear_addrs();
  static const int kAddrsFieldNumber = 2;
  inline const ::gim::Address& addrs(int index) const;
  inline ::gim::Address* mutable_addrs(int index);
  inline ::gim::Address* add_addrs();
  inline const ::google::protobuf::RepeatedPtrField< ::gim::Address >&
      addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::gim::Address >*
      mutable_addrs();

  // @@protoc_insertion_point(class_scope:gim.RedirectResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::gim::Address > addrs_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static RedirectResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServiceRequest : public ::google::protobuf::Message {
 public:
  ServiceRequest();
  virtual ~ServiceRequest();

  ServiceRequest(const ServiceRequest& from);

  inline ServiceRequest& operator=(const ServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceRequest& default_instance();

  void Swap(ServiceRequest* other);

  // implements Message ----------------------------------------------

  ServiceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceRequest& from);
  void MergeFrom(const ServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string from_sessid = 1;
  inline bool has_from_sessid() const;
  inline void clear_from_sessid();
  static const int kFromSessidFieldNumber = 1;
  inline const ::std::string& from_sessid() const;
  inline void set_from_sessid(const ::std::string& value);
  inline void set_from_sessid(const char* value);
  inline void set_from_sessid(const char* value, size_t size);
  inline ::std::string* mutable_from_sessid();
  inline ::std::string* release_from_sessid();
  inline void set_allocated_from_sessid(::std::string* from_sessid);

  // optional string to_sessid = 2;
  inline bool has_to_sessid() const;
  inline void clear_to_sessid();
  static const int kToSessidFieldNumber = 2;
  inline const ::std::string& to_sessid() const;
  inline void set_to_sessid(const ::std::string& value);
  inline void set_to_sessid(const char* value);
  inline void set_to_sessid(const char* value, size_t size);
  inline ::std::string* mutable_to_sessid();
  inline ::std::string* release_to_sessid();
  inline void set_allocated_to_sessid(::std::string* to_sessid);

  // required int32 from_type = 3;
  inline bool has_from_type() const;
  inline void clear_from_type();
  static const int kFromTypeFieldNumber = 3;
  inline ::google::protobuf::int32 from_type() const;
  inline void set_from_type(::google::protobuf::int32 value);

  // required int32 to_type = 4;
  inline bool has_to_type() const;
  inline void clear_to_type();
  static const int kToTypeFieldNumber = 4;
  inline ::google::protobuf::int32 to_type() const;
  inline void set_to_type(::google::protobuf::int32 value);

  // required string sn = 5;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 5;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // optional bytes payload = 6;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 6;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:gim.ServiceRequest)
 private:
  inline void set_has_from_sessid();
  inline void clear_has_from_sessid();
  inline void set_has_to_sessid();
  inline void clear_has_to_sessid();
  inline void set_has_from_type();
  inline void clear_has_from_type();
  inline void set_has_to_type();
  inline void clear_has_to_type();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_sessid_;
  ::std::string* to_sessid_;
  ::google::protobuf::int32 from_type_;
  ::google::protobuf::int32 to_type_;
  ::std::string* sn_;
  ::std::string* payload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static ServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse : public ::google::protobuf::Message {
 public:
  ServiceResponse();
  virtual ~ServiceResponse();

  ServiceResponse(const ServiceResponse& from);

  inline ServiceResponse& operator=(const ServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse& default_instance();

  void Swap(ServiceResponse* other);

  // implements Message ----------------------------------------------

  ServiceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse& from);
  void MergeFrom(const ServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string from_sessid = 1;
  inline bool has_from_sessid() const;
  inline void clear_from_sessid();
  static const int kFromSessidFieldNumber = 1;
  inline const ::std::string& from_sessid() const;
  inline void set_from_sessid(const ::std::string& value);
  inline void set_from_sessid(const char* value);
  inline void set_from_sessid(const char* value, size_t size);
  inline ::std::string* mutable_from_sessid();
  inline ::std::string* release_from_sessid();
  inline void set_allocated_from_sessid(::std::string* from_sessid);

  // optional string to_sessid = 2;
  inline bool has_to_sessid() const;
  inline void clear_to_sessid();
  static const int kToSessidFieldNumber = 2;
  inline const ::std::string& to_sessid() const;
  inline void set_to_sessid(const ::std::string& value);
  inline void set_to_sessid(const char* value);
  inline void set_to_sessid(const char* value, size_t size);
  inline ::std::string* mutable_to_sessid();
  inline ::std::string* release_to_sessid();
  inline void set_allocated_to_sessid(::std::string* to_sessid);

  // required int32 from_type = 3;
  inline bool has_from_type() const;
  inline void clear_from_type();
  static const int kFromTypeFieldNumber = 3;
  inline ::google::protobuf::int32 from_type() const;
  inline void set_from_type(::google::protobuf::int32 value);

  // required int32 to_type = 4;
  inline bool has_to_type() const;
  inline void clear_to_type();
  static const int kToTypeFieldNumber = 4;
  inline ::google::protobuf::int32 to_type() const;
  inline void set_to_type(::google::protobuf::int32 value);

  // required string sn = 5;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 5;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // required int32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional bytes payload = 7;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 7;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:gim.ServiceResponse)
 private:
  inline void set_has_from_sessid();
  inline void clear_has_from_sessid();
  inline void set_has_to_sessid();
  inline void clear_has_to_sessid();
  inline void set_has_from_type();
  inline void clear_has_from_type();
  inline void set_has_to_type();
  inline void clear_has_to_type();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_sessid_;
  ::std::string* to_sessid_;
  ::google::protobuf::int32 from_type_;
  ::google::protobuf::int32 to_type_;
  ::std::string* sn_;
  ::std::string* payload_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class KickCliRequest : public ::google::protobuf::Message {
 public:
  KickCliRequest();
  virtual ~KickCliRequest();

  KickCliRequest(const KickCliRequest& from);

  inline KickCliRequest& operator=(const KickCliRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KickCliRequest& default_instance();

  void Swap(KickCliRequest* other);

  // implements Message ----------------------------------------------

  KickCliRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KickCliRequest& from);
  void MergeFrom(const KickCliRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sessid = 1;
  inline bool has_sessid() const;
  inline void clear_sessid();
  static const int kSessidFieldNumber = 1;
  inline const ::std::string& sessid() const;
  inline void set_sessid(const ::std::string& value);
  inline void set_sessid(const char* value);
  inline void set_sessid(const char* value, size_t size);
  inline ::std::string* mutable_sessid();
  inline ::std::string* release_sessid();
  inline void set_allocated_sessid(::std::string* sessid);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional bytes reason = 4;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 4;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const void* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:gim.KickCliRequest)
 private:
  inline void set_has_sessid();
  inline void clear_has_sessid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sessid_;
  ::std::string* id_;
  ::std::string* reason_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static KickCliRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string id = 1;
inline bool LoginRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& LoginRequest::id() const {
  return *id_;
}
inline void LoginRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void LoginRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void LoginRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* LoginRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 type = 2;
inline bool LoginRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 LoginRequest::type() const {
  return type_;
}
inline void LoginRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string version = 3;
inline bool LoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& LoginRequest::version() const {
  return *version_;
}
inline void LoginRequest::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LoginRequest::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 4;
inline bool LoginRequest::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& LoginRequest::token() const {
  return *token_;
}
inline void LoginRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* LoginRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .gim.Pair kvs = 5;
inline int LoginRequest::kvs_size() const {
  return kvs_.size();
}
inline void LoginRequest::clear_kvs() {
  kvs_.Clear();
}
inline const ::gim::Pair& LoginRequest::kvs(int index) const {
  return kvs_.Get(index);
}
inline ::gim::Pair* LoginRequest::mutable_kvs(int index) {
  return kvs_.Mutable(index);
}
inline ::gim::Pair* LoginRequest::add_kvs() {
  return kvs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gim::Pair >&
LoginRequest::kvs() const {
  return kvs_;
}
inline ::google::protobuf::RepeatedPtrField< ::gim::Pair >*
LoginRequest::mutable_kvs() {
  return &kvs_;
}

// -------------------------------------------------------------------

// LoginResponse

// required int32 status = 1;
inline bool LoginResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 LoginResponse::status() const {
  return status_;
}
inline void LoginResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string sessid = 2;
inline bool LoginResponse::has_sessid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_sessid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_sessid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_sessid() {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    sessid_->clear();
  }
  clear_has_sessid();
}
inline const ::std::string& LoginResponse::sessid() const {
  return *sessid_;
}
inline void LoginResponse::set_sessid(const ::std::string& value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value, size_t size) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_sessid() {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  return sessid_;
}
inline ::std::string* LoginResponse::release_sessid() {
  clear_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessid_;
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_sessid(::std::string* sessid) {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessid_;
  }
  if (sessid) {
    set_has_sessid();
    sessid_ = sessid;
  } else {
    clear_has_sessid();
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 server_time = 3;
inline bool LoginResponse::has_server_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_server_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_server_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_server_time() {
  server_time_ = GOOGLE_LONGLONG(0);
  clear_has_server_time();
}
inline ::google::protobuf::int64 LoginResponse::server_time() const {
  return server_time_;
}
inline void LoginResponse::set_server_time(::google::protobuf::int64 value) {
  set_has_server_time();
  server_time_ = value;
}

// -------------------------------------------------------------------

// Address

// optional string ip = 1;
inline bool Address::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Address::ip() const {
  return *ip_;
}
inline void Address::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Address::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Address::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Address::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 2;
inline bool Address::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Address::port() const {
  return port_;
}
inline void Address::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// RedirectResponse

// required int32 status = 1;
inline bool RedirectResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedirectResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedirectResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedirectResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 RedirectResponse::status() const {
  return status_;
}
inline void RedirectResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated .gim.Address addrs = 2;
inline int RedirectResponse::addrs_size() const {
  return addrs_.size();
}
inline void RedirectResponse::clear_addrs() {
  addrs_.Clear();
}
inline const ::gim::Address& RedirectResponse::addrs(int index) const {
  return addrs_.Get(index);
}
inline ::gim::Address* RedirectResponse::mutable_addrs(int index) {
  return addrs_.Mutable(index);
}
inline ::gim::Address* RedirectResponse::add_addrs() {
  return addrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gim::Address >&
RedirectResponse::addrs() const {
  return addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::gim::Address >*
RedirectResponse::mutable_addrs() {
  return &addrs_;
}

// -------------------------------------------------------------------

// ServiceRequest

// optional string from_sessid = 1;
inline bool ServiceRequest::has_from_sessid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceRequest::set_has_from_sessid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceRequest::clear_has_from_sessid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceRequest::clear_from_sessid() {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    from_sessid_->clear();
  }
  clear_has_from_sessid();
}
inline const ::std::string& ServiceRequest::from_sessid() const {
  return *from_sessid_;
}
inline void ServiceRequest::set_from_sessid(const ::std::string& value) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void ServiceRequest::set_from_sessid(const char* value) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void ServiceRequest::set_from_sessid(const char* value, size_t size) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_from_sessid() {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  return from_sessid_;
}
inline ::std::string* ServiceRequest::release_from_sessid() {
  clear_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_sessid_;
    from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceRequest::set_allocated_from_sessid(::std::string* from_sessid) {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete from_sessid_;
  }
  if (from_sessid) {
    set_has_from_sessid();
    from_sessid_ = from_sessid;
  } else {
    clear_has_from_sessid();
    from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to_sessid = 2;
inline bool ServiceRequest::has_to_sessid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceRequest::set_has_to_sessid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceRequest::clear_has_to_sessid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceRequest::clear_to_sessid() {
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    to_sessid_->clear();
  }
  clear_has_to_sessid();
}
inline const ::std::string& ServiceRequest::to_sessid() const {
  return *to_sessid_;
}
inline void ServiceRequest::set_to_sessid(const ::std::string& value) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void ServiceRequest::set_to_sessid(const char* value) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void ServiceRequest::set_to_sessid(const char* value, size_t size) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_to_sessid() {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  return to_sessid_;
}
inline ::std::string* ServiceRequest::release_to_sessid() {
  clear_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_sessid_;
    to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceRequest::set_allocated_to_sessid(::std::string* to_sessid) {
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete to_sessid_;
  }
  if (to_sessid) {
    set_has_to_sessid();
    to_sessid_ = to_sessid;
  } else {
    clear_has_to_sessid();
    to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 from_type = 3;
inline bool ServiceRequest::has_from_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceRequest::set_has_from_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceRequest::clear_has_from_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceRequest::clear_from_type() {
  from_type_ = 0;
  clear_has_from_type();
}
inline ::google::protobuf::int32 ServiceRequest::from_type() const {
  return from_type_;
}
inline void ServiceRequest::set_from_type(::google::protobuf::int32 value) {
  set_has_from_type();
  from_type_ = value;
}

// required int32 to_type = 4;
inline bool ServiceRequest::has_to_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceRequest::set_has_to_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceRequest::clear_has_to_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceRequest::clear_to_type() {
  to_type_ = 0;
  clear_has_to_type();
}
inline ::google::protobuf::int32 ServiceRequest::to_type() const {
  return to_type_;
}
inline void ServiceRequest::set_to_type(::google::protobuf::int32 value) {
  set_has_to_type();
  to_type_ = value;
}

// required string sn = 5;
inline bool ServiceRequest::has_sn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceRequest::set_has_sn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceRequest::clear_has_sn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceRequest::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& ServiceRequest::sn() const {
  return *sn_;
}
inline void ServiceRequest::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceRequest::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceRequest::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* ServiceRequest::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceRequest::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes payload = 6;
inline bool ServiceRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceRequest::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& ServiceRequest::payload() const {
  return *payload_;
}
inline void ServiceRequest::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceRequest::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceRequest::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* ServiceRequest::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceRequest::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServiceResponse

// optional string from_sessid = 1;
inline bool ServiceResponse::has_from_sessid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse::set_has_from_sessid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse::clear_has_from_sessid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse::clear_from_sessid() {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    from_sessid_->clear();
  }
  clear_has_from_sessid();
}
inline const ::std::string& ServiceResponse::from_sessid() const {
  return *from_sessid_;
}
inline void ServiceResponse::set_from_sessid(const ::std::string& value) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void ServiceResponse::set_from_sessid(const char* value) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void ServiceResponse::set_from_sessid(const char* value, size_t size) {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_from_sessid() {
  set_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    from_sessid_ = new ::std::string;
  }
  return from_sessid_;
}
inline ::std::string* ServiceResponse::release_from_sessid() {
  clear_has_from_sessid();
  if (from_sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_sessid_;
    from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse::set_allocated_from_sessid(::std::string* from_sessid) {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete from_sessid_;
  }
  if (from_sessid) {
    set_has_from_sessid();
    from_sessid_ = from_sessid;
  } else {
    clear_has_from_sessid();
    from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to_sessid = 2;
inline bool ServiceResponse::has_to_sessid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse::set_has_to_sessid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse::clear_has_to_sessid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse::clear_to_sessid() {
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    to_sessid_->clear();
  }
  clear_has_to_sessid();
}
inline const ::std::string& ServiceResponse::to_sessid() const {
  return *to_sessid_;
}
inline void ServiceResponse::set_to_sessid(const ::std::string& value) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void ServiceResponse::set_to_sessid(const char* value) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void ServiceResponse::set_to_sessid(const char* value, size_t size) {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_to_sessid() {
  set_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    to_sessid_ = new ::std::string;
  }
  return to_sessid_;
}
inline ::std::string* ServiceResponse::release_to_sessid() {
  clear_has_to_sessid();
  if (to_sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_sessid_;
    to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse::set_allocated_to_sessid(::std::string* to_sessid) {
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete to_sessid_;
  }
  if (to_sessid) {
    set_has_to_sessid();
    to_sessid_ = to_sessid;
  } else {
    clear_has_to_sessid();
    to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 from_type = 3;
inline bool ServiceResponse::has_from_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceResponse::set_has_from_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceResponse::clear_has_from_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceResponse::clear_from_type() {
  from_type_ = 0;
  clear_has_from_type();
}
inline ::google::protobuf::int32 ServiceResponse::from_type() const {
  return from_type_;
}
inline void ServiceResponse::set_from_type(::google::protobuf::int32 value) {
  set_has_from_type();
  from_type_ = value;
}

// required int32 to_type = 4;
inline bool ServiceResponse::has_to_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceResponse::set_has_to_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceResponse::clear_has_to_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceResponse::clear_to_type() {
  to_type_ = 0;
  clear_has_to_type();
}
inline ::google::protobuf::int32 ServiceResponse::to_type() const {
  return to_type_;
}
inline void ServiceResponse::set_to_type(::google::protobuf::int32 value) {
  set_has_to_type();
  to_type_ = value;
}

// required string sn = 5;
inline bool ServiceResponse::has_sn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceResponse::set_has_sn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceResponse::clear_has_sn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceResponse::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& ServiceResponse::sn() const {
  return *sn_;
}
inline void ServiceResponse::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceResponse::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceResponse::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* ServiceResponse::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 6;
inline bool ServiceResponse::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceResponse::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ServiceResponse::status() const {
  return status_;
}
inline void ServiceResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional bytes payload = 7;
inline bool ServiceResponse::has_payload() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServiceResponse::set_has_payload() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServiceResponse::clear_has_payload() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServiceResponse::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& ServiceResponse::payload() const {
  return *payload_;
}
inline void ServiceResponse::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceResponse::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceResponse::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* ServiceResponse::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// KickCliRequest

// optional string sessid = 1;
inline bool KickCliRequest::has_sessid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickCliRequest::set_has_sessid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickCliRequest::clear_has_sessid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickCliRequest::clear_sessid() {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    sessid_->clear();
  }
  clear_has_sessid();
}
inline const ::std::string& KickCliRequest::sessid() const {
  return *sessid_;
}
inline void KickCliRequest::set_sessid(const ::std::string& value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void KickCliRequest::set_sessid(const char* value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void KickCliRequest::set_sessid(const char* value, size_t size) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KickCliRequest::mutable_sessid() {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  return sessid_;
}
inline ::std::string* KickCliRequest::release_sessid() {
  clear_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessid_;
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KickCliRequest::set_allocated_sessid(::std::string* sessid) {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessid_;
  }
  if (sessid) {
    set_has_sessid();
    sessid_ = sessid;
  } else {
    clear_has_sessid();
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 2;
inline bool KickCliRequest::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickCliRequest::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickCliRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickCliRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& KickCliRequest::id() const {
  return *id_;
}
inline void KickCliRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void KickCliRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void KickCliRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KickCliRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* KickCliRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KickCliRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 type = 3;
inline bool KickCliRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KickCliRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KickCliRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KickCliRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 KickCliRequest::type() const {
  return type_;
}
inline void KickCliRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes reason = 4;
inline bool KickCliRequest::has_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KickCliRequest::set_has_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KickCliRequest::clear_has_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KickCliRequest::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& KickCliRequest::reason() const {
  return *reason_;
}
inline void KickCliRequest::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void KickCliRequest::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void KickCliRequest::set_reason(const void* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KickCliRequest::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* KickCliRequest::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KickCliRequest::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gim

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_connect_5fserver_2eproto__INCLUDED
