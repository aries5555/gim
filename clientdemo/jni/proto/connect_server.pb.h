// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connect_server.proto

#ifndef PROTOBUF_connect_5fserver_2eproto__INCLUDED
#define PROTOBUF_connect_5fserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "pair.pb.h"
// @@protoc_insertion_point(includes)

namespace gim {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_connect_5fserver_2eproto();
void protobuf_AssignDesc_connect_5fserver_2eproto();
void protobuf_ShutdownFile_connect_5fserver_2eproto();

class LoginRequest;
class LoginResponse;
class Address;
class RedirectResponse;
class SetTimeResponse;
class ServiceRequest;
class ServiceResponse;
class SvRegRequest;
class SvRegResponse;
class KickCliRequest;

// ===================================================================

class LoginRequest : public ::google::protobuf::MessageLite {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional int32 enc = 4;
  inline bool has_enc() const;
  inline void clear_enc();
  static const int kEncFieldNumber = 4;
  inline ::google::protobuf::int32 enc() const;
  inline void set_enc(::google::protobuf::int32 value);

  // optional string token = 5;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // repeated .gim.Pair kvs = 6;
  inline int kvs_size() const;
  inline void clear_kvs();
  static const int kKvsFieldNumber = 6;
  inline const ::gim::Pair& kvs(int index) const;
  inline ::gim::Pair* mutable_kvs(int index);
  inline ::gim::Pair* add_kvs();
  inline const ::google::protobuf::RepeatedPtrField< ::gim::Pair >&
      kvs() const;
  inline ::google::protobuf::RepeatedPtrField< ::gim::Pair >*
      mutable_kvs();

  // @@protoc_insertion_point(class_scope:gim.LoginRequest)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_enc();
  inline void clear_has_enc();
  inline void set_has_token();
  inline void clear_has_token();

  ::std::string* cid_;
  ::google::protobuf::int64 time_;
  ::std::string* version_;
  ::std::string* token_;
  ::google::protobuf::RepeatedPtrField< ::gim::Pair > kvs_;
  ::google::protobuf::int32 enc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::MessageLite {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string sessid = 2;
  inline bool has_sessid() const;
  inline void clear_sessid();
  static const int kSessidFieldNumber = 2;
  inline const ::std::string& sessid() const;
  inline void set_sessid(const ::std::string& value);
  inline void set_sessid(const char* value);
  inline void set_sessid(const char* value, size_t size);
  inline ::std::string* mutable_sessid();
  inline ::std::string* release_sessid();
  inline void set_allocated_sessid(::std::string* sessid);

  // optional int64 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:gim.LoginResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_sessid();
  inline void clear_has_sessid();
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string* sessid_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::MessageLite {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  static const Address& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Address* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gim.Address)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::std::string* ip_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class RedirectResponse : public ::google::protobuf::MessageLite {
 public:
  RedirectResponse();
  virtual ~RedirectResponse();

  RedirectResponse(const RedirectResponse& from);

  inline RedirectResponse& operator=(const RedirectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const RedirectResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RedirectResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RedirectResponse* other);

  // implements Message ----------------------------------------------

  RedirectResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RedirectResponse& from);
  void MergeFrom(const RedirectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // repeated .gim.Address addrs = 2;
  inline int addrs_size() const;
  inline void clear_addrs();
  static const int kAddrsFieldNumber = 2;
  inline const ::gim::Address& addrs(int index) const;
  inline ::gim::Address* mutable_addrs(int index);
  inline ::gim::Address* add_addrs();
  inline const ::google::protobuf::RepeatedPtrField< ::gim::Address >&
      addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::gim::Address >*
      mutable_addrs();

  // @@protoc_insertion_point(class_scope:gim.RedirectResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedPtrField< ::gim::Address > addrs_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static RedirectResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetTimeResponse : public ::google::protobuf::MessageLite {
 public:
  SetTimeResponse();
  virtual ~SetTimeResponse();

  SetTimeResponse(const SetTimeResponse& from);

  inline SetTimeResponse& operator=(const SetTimeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetTimeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetTimeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetTimeResponse* other);

  // implements Message ----------------------------------------------

  SetTimeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetTimeResponse& from);
  void MergeFrom(const SetTimeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // required int64 server_time = 2;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 2;
  inline ::google::protobuf::int64 server_time() const;
  inline void set_server_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:gim.SetTimeResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_server_time();
  inline void clear_has_server_time();

  ::google::protobuf::int64 server_time_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static SetTimeResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServiceRequest : public ::google::protobuf::MessageLite {
 public:
  ServiceRequest();
  virtual ~ServiceRequest();

  ServiceRequest(const ServiceRequest& from);

  inline ServiceRequest& operator=(const ServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ServiceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServiceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServiceRequest* other);

  // implements Message ----------------------------------------------

  ServiceRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServiceRequest& from);
  void MergeFrom(const ServiceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sessid = 1;
  inline bool has_sessid() const;
  inline void clear_sessid();
  static const int kSessidFieldNumber = 1;
  inline const ::std::string& sessid() const;
  inline void set_sessid(const ::std::string& value);
  inline void set_sessid(const char* value);
  inline void set_sessid(const char* value, size_t size);
  inline ::std::string* mutable_sessid();
  inline ::std::string* release_sessid();
  inline void set_allocated_sessid(::std::string* sessid);

  // required int32 svtype = 2;
  inline bool has_svtype() const;
  inline void clear_svtype();
  static const int kSvtypeFieldNumber = 2;
  inline ::google::protobuf::int32 svtype() const;
  inline void set_svtype(::google::protobuf::int32 value);

  // required string sn = 3;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 3;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // optional bytes payload = 4;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 4;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:gim.ServiceRequest)
 private:
  inline void set_has_sessid();
  inline void clear_has_sessid();
  inline void set_has_svtype();
  inline void clear_has_svtype();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::std::string* sessid_;
  ::std::string* sn_;
  ::std::string* payload_;
  ::google::protobuf::int32 svtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static ServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse : public ::google::protobuf::MessageLite {
 public:
  ServiceResponse();
  virtual ~ServiceResponse();

  ServiceResponse(const ServiceResponse& from);

  inline ServiceResponse& operator=(const ServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ServiceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ServiceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ServiceResponse* other);

  // implements Message ----------------------------------------------

  ServiceResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ServiceResponse& from);
  void MergeFrom(const ServiceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sessid = 1;
  inline bool has_sessid() const;
  inline void clear_sessid();
  static const int kSessidFieldNumber = 1;
  inline const ::std::string& sessid() const;
  inline void set_sessid(const ::std::string& value);
  inline void set_sessid(const char* value);
  inline void set_sessid(const char* value, size_t size);
  inline ::std::string* mutable_sessid();
  inline ::std::string* release_sessid();
  inline void set_allocated_sessid(::std::string* sessid);

  // required int32 svtype = 2;
  inline bool has_svtype() const;
  inline void clear_svtype();
  static const int kSvtypeFieldNumber = 2;
  inline ::google::protobuf::int32 svtype() const;
  inline void set_svtype(::google::protobuf::int32 value);

  // required string sn = 3;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 3;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // required int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional bytes payload = 5;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 5;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:gim.ServiceResponse)
 private:
  inline void set_has_sessid();
  inline void clear_has_sessid();
  inline void set_has_svtype();
  inline void clear_has_svtype();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::std::string* sessid_;
  ::std::string* sn_;
  ::google::protobuf::int32 svtype_;
  ::google::protobuf::int32 status_;
  ::std::string* payload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static ServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class SvRegRequest : public ::google::protobuf::MessageLite {
 public:
  SvRegRequest();
  virtual ~SvRegRequest();

  SvRegRequest(const SvRegRequest& from);

  inline SvRegRequest& operator=(const SvRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const SvRegRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SvRegRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SvRegRequest* other);

  // implements Message ----------------------------------------------

  SvRegRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SvRegRequest& from);
  void MergeFrom(const SvRegRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 svtype = 1;
  inline bool has_svtype() const;
  inline void clear_svtype();
  static const int kSvtypeFieldNumber = 1;
  inline ::google::protobuf::int32 svtype() const;
  inline void set_svtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gim.SvRegRequest)
 private:
  inline void set_has_svtype();
  inline void clear_has_svtype();

  ::google::protobuf::int32 svtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static SvRegRequest* default_instance_;
};
// -------------------------------------------------------------------

class SvRegResponse : public ::google::protobuf::MessageLite {
 public:
  SvRegResponse();
  virtual ~SvRegResponse();

  SvRegResponse(const SvRegResponse& from);

  inline SvRegResponse& operator=(const SvRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const SvRegResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SvRegResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SvRegResponse* other);

  // implements Message ----------------------------------------------

  SvRegResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SvRegResponse& from);
  void MergeFrom(const SvRegResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gim.SvRegResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static SvRegResponse* default_instance_;
};
// -------------------------------------------------------------------

class KickCliRequest : public ::google::protobuf::MessageLite {
 public:
  KickCliRequest();
  virtual ~KickCliRequest();

  KickCliRequest(const KickCliRequest& from);

  inline KickCliRequest& operator=(const KickCliRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const KickCliRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KickCliRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KickCliRequest* other);

  // implements Message ----------------------------------------------

  KickCliRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KickCliRequest& from);
  void MergeFrom(const KickCliRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const void* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:gim.KickCliRequest)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();

  ::std::string* reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_connect_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();

  void InitAsDefaultInstance();
  static KickCliRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string cid = 1;
inline bool LoginRequest::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& LoginRequest::cid() const {
  return *cid_;
}
inline void LoginRequest::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void LoginRequest::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void LoginRequest::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* LoginRequest::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 time = 2;
inline bool LoginRequest::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 LoginRequest::time() const {
  return time_;
}
inline void LoginRequest::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string version = 3;
inline bool LoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& LoginRequest::version() const {
  return *version_;
}
inline void LoginRequest::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LoginRequest::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 enc = 4;
inline bool LoginRequest::has_enc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_enc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_enc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_enc() {
  enc_ = 0;
  clear_has_enc();
}
inline ::google::protobuf::int32 LoginRequest::enc() const {
  return enc_;
}
inline void LoginRequest::set_enc(::google::protobuf::int32 value) {
  set_has_enc();
  enc_ = value;
}

// optional string token = 5;
inline bool LoginRequest::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequest::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& LoginRequest::token() const {
  return *token_;
}
inline void LoginRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* LoginRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .gim.Pair kvs = 6;
inline int LoginRequest::kvs_size() const {
  return kvs_.size();
}
inline void LoginRequest::clear_kvs() {
  kvs_.Clear();
}
inline const ::gim::Pair& LoginRequest::kvs(int index) const {
  return kvs_.Get(index);
}
inline ::gim::Pair* LoginRequest::mutable_kvs(int index) {
  return kvs_.Mutable(index);
}
inline ::gim::Pair* LoginRequest::add_kvs() {
  return kvs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gim::Pair >&
LoginRequest::kvs() const {
  return kvs_;
}
inline ::google::protobuf::RepeatedPtrField< ::gim::Pair >*
LoginRequest::mutable_kvs() {
  return &kvs_;
}

// -------------------------------------------------------------------

// LoginResponse

// required int32 status = 1;
inline bool LoginResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 LoginResponse::status() const {
  return status_;
}
inline void LoginResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string sessid = 2;
inline bool LoginResponse::has_sessid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_sessid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_sessid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_sessid() {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    sessid_->clear();
  }
  clear_has_sessid();
}
inline const ::std::string& LoginResponse::sessid() const {
  return *sessid_;
}
inline void LoginResponse::set_sessid(const ::std::string& value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value, size_t size) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_sessid() {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  return sessid_;
}
inline ::std::string* LoginResponse::release_sessid() {
  clear_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessid_;
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_sessid(::std::string* sessid) {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessid_;
  }
  if (sessid) {
    set_has_sessid();
    sessid_ = sessid;
  } else {
    clear_has_sessid();
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 time = 3;
inline bool LoginResponse::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 LoginResponse::time() const {
  return time_;
}
inline void LoginResponse::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// Address

// optional string ip = 1;
inline bool Address::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Address::ip() const {
  return *ip_;
}
inline void Address::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Address::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Address::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Address::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 2;
inline bool Address::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Address::port() const {
  return port_;
}
inline void Address::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// RedirectResponse

// required int32 status = 1;
inline bool RedirectResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedirectResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedirectResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedirectResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 RedirectResponse::status() const {
  return status_;
}
inline void RedirectResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated .gim.Address addrs = 2;
inline int RedirectResponse::addrs_size() const {
  return addrs_.size();
}
inline void RedirectResponse::clear_addrs() {
  addrs_.Clear();
}
inline const ::gim::Address& RedirectResponse::addrs(int index) const {
  return addrs_.Get(index);
}
inline ::gim::Address* RedirectResponse::mutable_addrs(int index) {
  return addrs_.Mutable(index);
}
inline ::gim::Address* RedirectResponse::add_addrs() {
  return addrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gim::Address >&
RedirectResponse::addrs() const {
  return addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::gim::Address >*
RedirectResponse::mutable_addrs() {
  return &addrs_;
}

// -------------------------------------------------------------------

// SetTimeResponse

// required int32 status = 1;
inline bool SetTimeResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetTimeResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetTimeResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetTimeResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 SetTimeResponse::status() const {
  return status_;
}
inline void SetTimeResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int64 server_time = 2;
inline bool SetTimeResponse::has_server_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetTimeResponse::set_has_server_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetTimeResponse::clear_has_server_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetTimeResponse::clear_server_time() {
  server_time_ = GOOGLE_LONGLONG(0);
  clear_has_server_time();
}
inline ::google::protobuf::int64 SetTimeResponse::server_time() const {
  return server_time_;
}
inline void SetTimeResponse::set_server_time(::google::protobuf::int64 value) {
  set_has_server_time();
  server_time_ = value;
}

// -------------------------------------------------------------------

// ServiceRequest

// required string sessid = 1;
inline bool ServiceRequest::has_sessid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceRequest::set_has_sessid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceRequest::clear_has_sessid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceRequest::clear_sessid() {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    sessid_->clear();
  }
  clear_has_sessid();
}
inline const ::std::string& ServiceRequest::sessid() const {
  return *sessid_;
}
inline void ServiceRequest::set_sessid(const ::std::string& value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void ServiceRequest::set_sessid(const char* value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void ServiceRequest::set_sessid(const char* value, size_t size) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_sessid() {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  return sessid_;
}
inline ::std::string* ServiceRequest::release_sessid() {
  clear_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessid_;
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceRequest::set_allocated_sessid(::std::string* sessid) {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessid_;
  }
  if (sessid) {
    set_has_sessid();
    sessid_ = sessid;
  } else {
    clear_has_sessid();
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 svtype = 2;
inline bool ServiceRequest::has_svtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceRequest::set_has_svtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceRequest::clear_has_svtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceRequest::clear_svtype() {
  svtype_ = 0;
  clear_has_svtype();
}
inline ::google::protobuf::int32 ServiceRequest::svtype() const {
  return svtype_;
}
inline void ServiceRequest::set_svtype(::google::protobuf::int32 value) {
  set_has_svtype();
  svtype_ = value;
}

// required string sn = 3;
inline bool ServiceRequest::has_sn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceRequest::set_has_sn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceRequest::clear_has_sn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceRequest::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& ServiceRequest::sn() const {
  return *sn_;
}
inline void ServiceRequest::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceRequest::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceRequest::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* ServiceRequest::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceRequest::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes payload = 4;
inline bool ServiceRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceRequest::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& ServiceRequest::payload() const {
  return *payload_;
}
inline void ServiceRequest::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceRequest::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceRequest::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* ServiceRequest::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceRequest::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ServiceResponse

// required string sessid = 1;
inline bool ServiceResponse::has_sessid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceResponse::set_has_sessid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceResponse::clear_has_sessid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceResponse::clear_sessid() {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    sessid_->clear();
  }
  clear_has_sessid();
}
inline const ::std::string& ServiceResponse::sessid() const {
  return *sessid_;
}
inline void ServiceResponse::set_sessid(const ::std::string& value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void ServiceResponse::set_sessid(const char* value) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void ServiceResponse::set_sessid(const char* value, size_t size) {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_sessid() {
  set_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    sessid_ = new ::std::string;
  }
  return sessid_;
}
inline ::std::string* ServiceResponse::release_sessid() {
  clear_has_sessid();
  if (sessid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessid_;
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse::set_allocated_sessid(::std::string* sessid) {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessid_;
  }
  if (sessid) {
    set_has_sessid();
    sessid_ = sessid;
  } else {
    clear_has_sessid();
    sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 svtype = 2;
inline bool ServiceResponse::has_svtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceResponse::set_has_svtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceResponse::clear_has_svtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceResponse::clear_svtype() {
  svtype_ = 0;
  clear_has_svtype();
}
inline ::google::protobuf::int32 ServiceResponse::svtype() const {
  return svtype_;
}
inline void ServiceResponse::set_svtype(::google::protobuf::int32 value) {
  set_has_svtype();
  svtype_ = value;
}

// required string sn = 3;
inline bool ServiceResponse::has_sn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceResponse::set_has_sn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceResponse::clear_has_sn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceResponse::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& ServiceResponse::sn() const {
  return *sn_;
}
inline void ServiceResponse::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceResponse::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceResponse::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* ServiceResponse::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 4;
inline bool ServiceResponse::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceResponse::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ServiceResponse::status() const {
  return status_;
}
inline void ServiceResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional bytes payload = 5;
inline bool ServiceResponse::has_payload() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceResponse::set_has_payload() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceResponse::clear_has_payload() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceResponse::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& ServiceResponse::payload() const {
  return *payload_;
}
inline void ServiceResponse::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceResponse::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceResponse::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* ServiceResponse::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceResponse::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SvRegRequest

// required int32 svtype = 1;
inline bool SvRegRequest::has_svtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SvRegRequest::set_has_svtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SvRegRequest::clear_has_svtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SvRegRequest::clear_svtype() {
  svtype_ = 0;
  clear_has_svtype();
}
inline ::google::protobuf::int32 SvRegRequest::svtype() const {
  return svtype_;
}
inline void SvRegRequest::set_svtype(::google::protobuf::int32 value) {
  set_has_svtype();
  svtype_ = value;
}

// -------------------------------------------------------------------

// SvRegResponse

// required int32 status = 1;
inline bool SvRegResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SvRegResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SvRegResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SvRegResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 SvRegResponse::status() const {
  return status_;
}
inline void SvRegResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// KickCliRequest

// optional bytes reason = 1;
inline bool KickCliRequest::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickCliRequest::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickCliRequest::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickCliRequest::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& KickCliRequest::reason() const {
  return *reason_;
}
inline void KickCliRequest::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void KickCliRequest::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void KickCliRequest::set_reason(const void* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KickCliRequest::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* KickCliRequest::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KickCliRequest::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gim

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_connect_5fserver_2eproto__INCLUDED
