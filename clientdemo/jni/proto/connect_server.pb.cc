// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connect_server.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "connect_server.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace gim {

void protobuf_ShutdownFile_connect_5fserver_2eproto() {
  delete LoginRequest::default_instance_;
  delete LoginResponse::default_instance_;
  delete Address::default_instance_;
  delete RedirectResponse::default_instance_;
  delete SetTimeResponse::default_instance_;
  delete ServiceRequest::default_instance_;
  delete ServiceResponse::default_instance_;
  delete SvRegRequest::default_instance_;
  delete SvRegResponse::default_instance_;
  delete KickCliRequest::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_connect_5fserver_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_connect_5fserver_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::gim::protobuf_AddDesc_pair_2eproto();
  LoginRequest::default_instance_ = new LoginRequest();
  LoginResponse::default_instance_ = new LoginResponse();
  Address::default_instance_ = new Address();
  RedirectResponse::default_instance_ = new RedirectResponse();
  SetTimeResponse::default_instance_ = new SetTimeResponse();
  ServiceRequest::default_instance_ = new ServiceRequest();
  ServiceResponse::default_instance_ = new ServiceResponse();
  SvRegRequest::default_instance_ = new SvRegRequest();
  SvRegResponse::default_instance_ = new SvRegResponse();
  KickCliRequest::default_instance_ = new KickCliRequest();
  LoginRequest::default_instance_->InitAsDefaultInstance();
  LoginResponse::default_instance_->InitAsDefaultInstance();
  Address::default_instance_->InitAsDefaultInstance();
  RedirectResponse::default_instance_->InitAsDefaultInstance();
  SetTimeResponse::default_instance_->InitAsDefaultInstance();
  ServiceRequest::default_instance_->InitAsDefaultInstance();
  ServiceResponse::default_instance_->InitAsDefaultInstance();
  SvRegRequest::default_instance_->InitAsDefaultInstance();
  SvRegResponse::default_instance_->InitAsDefaultInstance();
  KickCliRequest::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_connect_5fserver_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_connect_5fserver_2eproto_once_);
void protobuf_AddDesc_connect_5fserver_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_connect_5fserver_2eproto_once_,
                 &protobuf_AddDesc_connect_5fserver_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_connect_5fserver_2eproto {
  StaticDescriptorInitializer_connect_5fserver_2eproto() {
    protobuf_AddDesc_connect_5fserver_2eproto();
  }
} static_descriptor_initializer_connect_5fserver_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int LoginRequest::kCidFieldNumber;
const int LoginRequest::kTimeFieldNumber;
const int LoginRequest::kVersionFieldNumber;
const int LoginRequest::kEncFieldNumber;
const int LoginRequest::kTokenFieldNumber;
const int LoginRequest::kKvsFieldNumber;
#endif  // !_MSC_VER

LoginRequest::LoginRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginRequest::InitAsDefaultInstance() {
}

LoginRequest::LoginRequest(const LoginRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginRequest::SharedCtor() {
  _cached_size_ = 0;
  cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  time_ = GOOGLE_LONGLONG(0);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  enc_ = 0;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginRequest::~LoginRequest() {
  SharedDtor();
}

void LoginRequest::SharedDtor() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginRequest& LoginRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

LoginRequest* LoginRequest::default_instance_ = NULL;

LoginRequest* LoginRequest::New() const {
  return new LoginRequest;
}

void LoginRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_cid()) {
      if (cid_ != &::google::protobuf::internal::kEmptyString) {
        cid_->clear();
      }
    }
    time_ = GOOGLE_LONGLONG(0);
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    enc_ = 0;
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
  }
  kvs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string cid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_time;
        break;
      }

      // optional int64 time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_version;
        break;
      }

      // optional string version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_enc;
        break;
      }

      // optional int32 enc = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enc_)));
          set_has_enc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_token;
        break;
      }

      // optional string token = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_kvs;
        break;
      }

      // repeated .gim.Pair kvs = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_kvs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_kvs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_kvs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string cid = 1;
  if (has_cid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->cid(), output);
  }

  // optional int64 time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->time(), output);
  }

  // optional string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->version(), output);
  }

  // optional int32 enc = 4;
  if (has_enc()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->enc(), output);
  }

  // optional string token = 5;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->token(), output);
  }

  // repeated .gim.Pair kvs = 6;
  for (int i = 0; i < this->kvs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->kvs(i), output);
  }

}

int LoginRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string cid = 1;
    if (has_cid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cid());
    }

    // optional int64 time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time());
    }

    // optional string version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional int32 enc = 4;
    if (has_enc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enc());
    }

    // optional string token = 5;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

  }
  // repeated .gim.Pair kvs = 6;
  total_size += 1 * this->kvs_size();
  for (int i = 0; i < this->kvs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->kvs(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginRequest*>(&from));
}

void LoginRequest::MergeFrom(const LoginRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  kvs_.MergeFrom(from.kvs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cid()) {
      set_cid(from.cid());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_enc()) {
      set_enc(from.enc());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
  }
}

void LoginRequest::CopyFrom(const LoginRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < kvs_size(); i++) {
    if (!this->kvs(i).IsInitialized()) return false;
  }
  return true;
}

void LoginRequest::Swap(LoginRequest* other) {
  if (other != this) {
    std::swap(cid_, other->cid_);
    std::swap(time_, other->time_);
    std::swap(version_, other->version_);
    std::swap(enc_, other->enc_);
    std::swap(token_, other->token_);
    kvs_.Swap(&other->kvs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginRequest::GetTypeName() const {
  return "gim.LoginRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginResponse::kStatusFieldNumber;
const int LoginResponse::kSessidFieldNumber;
const int LoginResponse::kTimeFieldNumber;
#endif  // !_MSC_VER

LoginResponse::LoginResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginResponse::InitAsDefaultInstance() {
}

LoginResponse::LoginResponse(const LoginResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginResponse::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginResponse::~LoginResponse() {
  SharedDtor();
}

void LoginResponse::SharedDtor() {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginResponse& LoginResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

LoginResponse* LoginResponse::default_instance_ = NULL;

LoginResponse* LoginResponse::New() const {
  return new LoginResponse;
}

void LoginResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
    if (has_sessid()) {
      if (sessid_ != &::google::protobuf::internal::kEmptyString) {
        sessid_->clear();
      }
    }
    time_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sessid;
        break;
      }

      // optional string sessid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sessid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sessid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_time;
        break;
      }

      // optional int64 time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

  // optional string sessid = 2;
  if (has_sessid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->sessid(), output);
  }

  // optional int64 time = 3;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->time(), output);
  }

}

int LoginResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

    // optional string sessid = 2;
    if (has_sessid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sessid());
    }

    // optional int64 time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginResponse*>(&from));
}

void LoginResponse::MergeFrom(const LoginResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_sessid()) {
      set_sessid(from.sessid());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
}

void LoginResponse::CopyFrom(const LoginResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LoginResponse::Swap(LoginResponse* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(sessid_, other->sessid_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginResponse::GetTypeName() const {
  return "gim.LoginResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int Address::kIpFieldNumber;
const int Address::kPortFieldNumber;
#endif  // !_MSC_VER

Address::Address()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Address::InitAsDefaultInstance() {
}

Address::Address(const Address& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Address::SharedCtor() {
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Address::~Address() {
  SharedDtor();
}

void Address::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Address& Address::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

Address* Address::default_instance_ = NULL;

Address* Address::New() const {
  return new Address;
}

void Address::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // optional int32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->ip(), output);
  }

  // optional int32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->port(), output);
  }

}

int Address::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional int32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Address*>(&from));
}

void Address::MergeFrom(const Address& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
}

void Address::CopyFrom(const Address& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {

  return true;
}

void Address::Swap(Address* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Address::GetTypeName() const {
  return "gim.Address";
}


// ===================================================================

#ifndef _MSC_VER
const int RedirectResponse::kStatusFieldNumber;
const int RedirectResponse::kAddrsFieldNumber;
#endif  // !_MSC_VER

RedirectResponse::RedirectResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RedirectResponse::InitAsDefaultInstance() {
}

RedirectResponse::RedirectResponse(const RedirectResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RedirectResponse::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RedirectResponse::~RedirectResponse() {
  SharedDtor();
}

void RedirectResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RedirectResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RedirectResponse& RedirectResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

RedirectResponse* RedirectResponse::default_instance_ = NULL;

RedirectResponse* RedirectResponse::New() const {
  return new RedirectResponse;
}

void RedirectResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  addrs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RedirectResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_addrs;
        break;
      }

      // repeated .gim.Address addrs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_addrs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_addrs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_addrs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RedirectResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

  // repeated .gim.Address addrs = 2;
  for (int i = 0; i < this->addrs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->addrs(i), output);
  }

}

int RedirectResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  // repeated .gim.Address addrs = 2;
  total_size += 1 * this->addrs_size();
  for (int i = 0; i < this->addrs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->addrs(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RedirectResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RedirectResponse*>(&from));
}

void RedirectResponse::MergeFrom(const RedirectResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  addrs_.MergeFrom(from.addrs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void RedirectResponse::CopyFrom(const RedirectResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RedirectResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RedirectResponse::Swap(RedirectResponse* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    addrs_.Swap(&other->addrs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RedirectResponse::GetTypeName() const {
  return "gim.RedirectResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int SetTimeResponse::kStatusFieldNumber;
const int SetTimeResponse::kServerTimeFieldNumber;
#endif  // !_MSC_VER

SetTimeResponse::SetTimeResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SetTimeResponse::InitAsDefaultInstance() {
}

SetTimeResponse::SetTimeResponse(const SetTimeResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SetTimeResponse::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  server_time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetTimeResponse::~SetTimeResponse() {
  SharedDtor();
}

void SetTimeResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SetTimeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetTimeResponse& SetTimeResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

SetTimeResponse* SetTimeResponse::default_instance_ = NULL;

SetTimeResponse* SetTimeResponse::New() const {
  return new SetTimeResponse;
}

void SetTimeResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
    server_time_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SetTimeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_server_time;
        break;
      }

      // required int64 server_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_server_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &server_time_)));
          set_has_server_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SetTimeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

  // required int64 server_time = 2;
  if (has_server_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->server_time(), output);
  }

}

int SetTimeResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

    // required int64 server_time = 2;
    if (has_server_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->server_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetTimeResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetTimeResponse*>(&from));
}

void SetTimeResponse::MergeFrom(const SetTimeResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_server_time()) {
      set_server_time(from.server_time());
    }
  }
}

void SetTimeResponse::CopyFrom(const SetTimeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetTimeResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SetTimeResponse::Swap(SetTimeResponse* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(server_time_, other->server_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SetTimeResponse::GetTypeName() const {
  return "gim.SetTimeResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int ServiceRequest::kFromSessidFieldNumber;
const int ServiceRequest::kToSessidFieldNumber;
const int ServiceRequest::kSvtypeFieldNumber;
const int ServiceRequest::kSnFieldNumber;
const int ServiceRequest::kPayloadFieldNumber;
const int ServiceRequest::kKeyFieldNumber;
const int ServiceRequest::kCallbackFieldNumber;
#endif  // !_MSC_VER

ServiceRequest::ServiceRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServiceRequest::InitAsDefaultInstance() {
}

ServiceRequest::ServiceRequest(const ServiceRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServiceRequest::SharedCtor() {
  _cached_size_ = 0;
  from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  svtype_ = 0;
  sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  callback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServiceRequest::~ServiceRequest() {
  SharedDtor();
}

void ServiceRequest::SharedDtor() {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete from_sessid_;
  }
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete to_sessid_;
  }
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (callback_ != &::google::protobuf::internal::kEmptyString) {
    delete callback_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServiceRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServiceRequest& ServiceRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

ServiceRequest* ServiceRequest::default_instance_ = NULL;

ServiceRequest* ServiceRequest::New() const {
  return new ServiceRequest;
}

void ServiceRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from_sessid()) {
      if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
        from_sessid_->clear();
      }
    }
    if (has_to_sessid()) {
      if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
        to_sessid_->clear();
      }
    }
    svtype_ = 0;
    if (has_sn()) {
      if (sn_ != &::google::protobuf::internal::kEmptyString) {
        sn_->clear();
      }
    }
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_callback()) {
      if (callback_ != &::google::protobuf::internal::kEmptyString) {
        callback_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServiceRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string from_sessid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from_sessid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to_sessid;
        break;
      }

      // optional string to_sessid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to_sessid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_to_sessid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_svtype;
        break;
      }

      // required int32 svtype = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_svtype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &svtype_)));
          set_has_svtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_sn;
        break;
      }

      // required string sn = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sn()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_payload;
        break;
      }

      // optional bytes payload = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_key;
        break;
      }

      // optional string key = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_callback;
        break;
      }

      // optional bytes callback = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_callback:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_callback()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServiceRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string from_sessid = 1;
  if (has_from_sessid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->from_sessid(), output);
  }

  // optional string to_sessid = 2;
  if (has_to_sessid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->to_sessid(), output);
  }

  // required int32 svtype = 3;
  if (has_svtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->svtype(), output);
  }

  // required string sn = 4;
  if (has_sn()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->sn(), output);
  }

  // optional bytes payload = 5;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->payload(), output);
  }

  // optional string key = 6;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->key(), output);
  }

  // optional bytes callback = 7;
  if (has_callback()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->callback(), output);
  }

}

int ServiceRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string from_sessid = 1;
    if (has_from_sessid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from_sessid());
    }

    // optional string to_sessid = 2;
    if (has_to_sessid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->to_sessid());
    }

    // required int32 svtype = 3;
    if (has_svtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->svtype());
    }

    // required string sn = 4;
    if (has_sn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sn());
    }

    // optional bytes payload = 5;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional string key = 6;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional bytes callback = 7;
    if (has_callback()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->callback());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServiceRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServiceRequest*>(&from));
}

void ServiceRequest::MergeFrom(const ServiceRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_sessid()) {
      set_from_sessid(from.from_sessid());
    }
    if (from.has_to_sessid()) {
      set_to_sessid(from.to_sessid());
    }
    if (from.has_svtype()) {
      set_svtype(from.svtype());
    }
    if (from.has_sn()) {
      set_sn(from.sn());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_callback()) {
      set_callback(from.callback());
    }
  }
}

void ServiceRequest::CopyFrom(const ServiceRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  return true;
}

void ServiceRequest::Swap(ServiceRequest* other) {
  if (other != this) {
    std::swap(from_sessid_, other->from_sessid_);
    std::swap(to_sessid_, other->to_sessid_);
    std::swap(svtype_, other->svtype_);
    std::swap(sn_, other->sn_);
    std::swap(payload_, other->payload_);
    std::swap(key_, other->key_);
    std::swap(callback_, other->callback_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServiceRequest::GetTypeName() const {
  return "gim.ServiceRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int ServiceResponse::kFromSessidFieldNumber;
const int ServiceResponse::kToSessidFieldNumber;
const int ServiceResponse::kSvtypeFieldNumber;
const int ServiceResponse::kSnFieldNumber;
const int ServiceResponse::kStatusFieldNumber;
const int ServiceResponse::kPayloadFieldNumber;
const int ServiceResponse::kCallbackFieldNumber;
#endif  // !_MSC_VER

ServiceResponse::ServiceResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ServiceResponse::InitAsDefaultInstance() {
}

ServiceResponse::ServiceResponse(const ServiceResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ServiceResponse::SharedCtor() {
  _cached_size_ = 0;
  from_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  to_sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  svtype_ = 0;
  sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = 0;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  callback_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServiceResponse::~ServiceResponse() {
  SharedDtor();
}

void ServiceResponse::SharedDtor() {
  if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete from_sessid_;
  }
  if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete to_sessid_;
  }
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (callback_ != &::google::protobuf::internal::kEmptyString) {
    delete callback_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ServiceResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServiceResponse& ServiceResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

ServiceResponse* ServiceResponse::default_instance_ = NULL;

ServiceResponse* ServiceResponse::New() const {
  return new ServiceResponse;
}

void ServiceResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_from_sessid()) {
      if (from_sessid_ != &::google::protobuf::internal::kEmptyString) {
        from_sessid_->clear();
      }
    }
    if (has_to_sessid()) {
      if (to_sessid_ != &::google::protobuf::internal::kEmptyString) {
        to_sessid_->clear();
      }
    }
    svtype_ = 0;
    if (has_sn()) {
      if (sn_ != &::google::protobuf::internal::kEmptyString) {
        sn_->clear();
      }
    }
    status_ = 0;
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
    if (has_callback()) {
      if (callback_ != &::google::protobuf::internal::kEmptyString) {
        callback_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ServiceResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string from_sessid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from_sessid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_to_sessid;
        break;
      }

      // required string to_sessid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to_sessid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_to_sessid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_svtype;
        break;
      }

      // required int32 svtype = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_svtype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &svtype_)));
          set_has_svtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_sn;
        break;
      }

      // required string sn = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sn()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_status;
        break;
      }

      // required int32 status = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_payload;
        break;
      }

      // optional bytes payload = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_callback;
        break;
      }

      // optional bytes callback = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_callback:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_callback()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServiceResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string from_sessid = 1;
  if (has_from_sessid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->from_sessid(), output);
  }

  // required string to_sessid = 2;
  if (has_to_sessid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->to_sessid(), output);
  }

  // required int32 svtype = 3;
  if (has_svtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->svtype(), output);
  }

  // required string sn = 4;
  if (has_sn()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->sn(), output);
  }

  // required int32 status = 5;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->status(), output);
  }

  // optional bytes payload = 6;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->payload(), output);
  }

  // optional bytes callback = 7;
  if (has_callback()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->callback(), output);
  }

}

int ServiceResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string from_sessid = 1;
    if (has_from_sessid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from_sessid());
    }

    // required string to_sessid = 2;
    if (has_to_sessid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->to_sessid());
    }

    // required int32 svtype = 3;
    if (has_svtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->svtype());
    }

    // required string sn = 4;
    if (has_sn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sn());
    }

    // required int32 status = 5;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

    // optional bytes payload = 6;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional bytes callback = 7;
    if (has_callback()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->callback());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServiceResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServiceResponse*>(&from));
}

void ServiceResponse::MergeFrom(const ServiceResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_sessid()) {
      set_from_sessid(from.from_sessid());
    }
    if (from.has_to_sessid()) {
      set_to_sessid(from.to_sessid());
    }
    if (from.has_svtype()) {
      set_svtype(from.svtype());
    }
    if (from.has_sn()) {
      set_sn(from.sn());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_callback()) {
      set_callback(from.callback());
    }
  }
}

void ServiceResponse::CopyFrom(const ServiceResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001e) != 0x0000001e) return false;

  return true;
}

void ServiceResponse::Swap(ServiceResponse* other) {
  if (other != this) {
    std::swap(from_sessid_, other->from_sessid_);
    std::swap(to_sessid_, other->to_sessid_);
    std::swap(svtype_, other->svtype_);
    std::swap(sn_, other->sn_);
    std::swap(status_, other->status_);
    std::swap(payload_, other->payload_);
    std::swap(callback_, other->callback_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ServiceResponse::GetTypeName() const {
  return "gim.ServiceResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int SvRegRequest::kSvtypeFieldNumber;
const int SvRegRequest::kIdFieldNumber;
#endif  // !_MSC_VER

SvRegRequest::SvRegRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SvRegRequest::InitAsDefaultInstance() {
}

SvRegRequest::SvRegRequest(const SvRegRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SvRegRequest::SharedCtor() {
  _cached_size_ = 0;
  svtype_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SvRegRequest::~SvRegRequest() {
  SharedDtor();
}

void SvRegRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SvRegRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SvRegRequest& SvRegRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

SvRegRequest* SvRegRequest::default_instance_ = NULL;

SvRegRequest* SvRegRequest::New() const {
  return new SvRegRequest;
}

void SvRegRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    svtype_ = 0;
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SvRegRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 svtype = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &svtype_)));
          set_has_svtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // required int32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SvRegRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 svtype = 1;
  if (has_svtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->svtype(), output);
  }

  // required int32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
  }

}

int SvRegRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 svtype = 1;
    if (has_svtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->svtype());
    }

    // required int32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SvRegRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SvRegRequest*>(&from));
}

void SvRegRequest::MergeFrom(const SvRegRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_svtype()) {
      set_svtype(from.svtype());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void SvRegRequest::CopyFrom(const SvRegRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SvRegRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SvRegRequest::Swap(SvRegRequest* other) {
  if (other != this) {
    std::swap(svtype_, other->svtype_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SvRegRequest::GetTypeName() const {
  return "gim.SvRegRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int SvRegResponse::kStatusFieldNumber;
const int SvRegResponse::kSessidFieldNumber;
#endif  // !_MSC_VER

SvRegResponse::SvRegResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SvRegResponse::InitAsDefaultInstance() {
}

SvRegResponse::SvRegResponse(const SvRegResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SvRegResponse::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  sessid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SvRegResponse::~SvRegResponse() {
  SharedDtor();
}

void SvRegResponse::SharedDtor() {
  if (sessid_ != &::google::protobuf::internal::kEmptyString) {
    delete sessid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SvRegResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SvRegResponse& SvRegResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

SvRegResponse* SvRegResponse::default_instance_ = NULL;

SvRegResponse* SvRegResponse::New() const {
  return new SvRegResponse;
}

void SvRegResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
    if (has_sessid()) {
      if (sessid_ != &::google::protobuf::internal::kEmptyString) {
        sessid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SvRegResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sessid;
        break;
      }

      // optional string sessid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sessid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sessid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SvRegResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

  // optional string sessid = 2;
  if (has_sessid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->sessid(), output);
  }

}

int SvRegResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

    // optional string sessid = 2;
    if (has_sessid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sessid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SvRegResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SvRegResponse*>(&from));
}

void SvRegResponse::MergeFrom(const SvRegResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_sessid()) {
      set_sessid(from.sessid());
    }
  }
}

void SvRegResponse::CopyFrom(const SvRegResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SvRegResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SvRegResponse::Swap(SvRegResponse* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(sessid_, other->sessid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SvRegResponse::GetTypeName() const {
  return "gim.SvRegResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int KickCliRequest::kReasonFieldNumber;
#endif  // !_MSC_VER

KickCliRequest::KickCliRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void KickCliRequest::InitAsDefaultInstance() {
}

KickCliRequest::KickCliRequest(const KickCliRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void KickCliRequest::SharedCtor() {
  _cached_size_ = 0;
  reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KickCliRequest::~KickCliRequest() {
  SharedDtor();
}

void KickCliRequest::SharedDtor() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void KickCliRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const KickCliRequest& KickCliRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_connect_5fserver_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_connect_5fserver_2eproto();
#endif
  return *default_instance_;
}

KickCliRequest* KickCliRequest::default_instance_ = NULL;

KickCliRequest* KickCliRequest::New() const {
  return new KickCliRequest;
}

void KickCliRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_reason()) {
      if (reason_ != &::google::protobuf::internal::kEmptyString) {
        reason_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool KickCliRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes reason = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reason()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KickCliRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes reason = 1;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->reason(), output);
  }

}

int KickCliRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes reason = 1;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reason());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KickCliRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const KickCliRequest*>(&from));
}

void KickCliRequest::MergeFrom(const KickCliRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reason()) {
      set_reason(from.reason());
    }
  }
}

void KickCliRequest::CopyFrom(const KickCliRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KickCliRequest::IsInitialized() const {

  return true;
}

void KickCliRequest::Swap(KickCliRequest* other) {
  if (other != this) {
    std::swap(reason_, other->reason_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string KickCliRequest::GetTypeName() const {
  return "gim.KickCliRequest";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gim

// @@protoc_insertion_point(global_scope)
