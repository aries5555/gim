// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: peer_server.proto

#ifndef PROTOBUF_peer_5fserver_2eproto__INCLUDED
#define PROTOBUF_peer_5fserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "message.pb.h"
// @@protoc_insertion_point(includes)

namespace gim {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_peer_5fserver_2eproto();
void protobuf_AssignDesc_peer_5fserver_2eproto();
void protobuf_ShutdownFile_peer_5fserver_2eproto();

class GetPeerMessageRequest;
class GetPeerMessageResponse;
class SendPeerMessageRequest;
class SendPeerMessageResponse;
class RecvPeerMessageResponse;
class PushMessageRequest;
class PushMessageResponse;
class PeerPacket;

// ===================================================================

class GetPeerMessageRequest : public ::google::protobuf::MessageLite {
 public:
  GetPeerMessageRequest();
  virtual ~GetPeerMessageRequest();

  GetPeerMessageRequest(const GetPeerMessageRequest& from);

  inline GetPeerMessageRequest& operator=(const GetPeerMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetPeerMessageRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetPeerMessageRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetPeerMessageRequest* other);

  // implements Message ----------------------------------------------

  GetPeerMessageRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetPeerMessageRequest& from);
  void MergeFrom(const GetPeerMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional int64 start_msgid = 2;
  inline bool has_start_msgid() const;
  inline void clear_start_msgid();
  static const int kStartMsgidFieldNumber = 2;
  inline ::google::protobuf::int64 start_msgid() const;
  inline void set_start_msgid(::google::protobuf::int64 value);

  // optional int64 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int64 count() const;
  inline void set_count(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:gim.GetPeerMessageRequest)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_start_msgid();
  inline void clear_has_start_msgid();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string* cid_;
  ::google::protobuf::int64 start_msgid_;
  ::google::protobuf::int64 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peer_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peer_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_peer_5fserver_2eproto();
  friend void protobuf_ShutdownFile_peer_5fserver_2eproto();

  void InitAsDefaultInstance();
  static GetPeerMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetPeerMessageResponse : public ::google::protobuf::MessageLite {
 public:
  GetPeerMessageResponse();
  virtual ~GetPeerMessageResponse();

  GetPeerMessageResponse(const GetPeerMessageResponse& from);

  inline GetPeerMessageResponse& operator=(const GetPeerMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetPeerMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetPeerMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetPeerMessageResponse* other);

  // implements Message ----------------------------------------------

  GetPeerMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetPeerMessageResponse& from);
  void MergeFrom(const GetPeerMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 last_msgid = 1;
  inline bool has_last_msgid() const;
  inline void clear_last_msgid();
  static const int kLastMsgidFieldNumber = 1;
  inline ::google::protobuf::int64 last_msgid() const;
  inline void set_last_msgid(::google::protobuf::int64 value);

  // repeated .gim.Message msgs = 2;
  inline int msgs_size() const;
  inline void clear_msgs();
  static const int kMsgsFieldNumber = 2;
  inline const ::gim::Message& msgs(int index) const;
  inline ::gim::Message* mutable_msgs(int index);
  inline ::gim::Message* add_msgs();
  inline const ::google::protobuf::RepeatedPtrField< ::gim::Message >&
      msgs() const;
  inline ::google::protobuf::RepeatedPtrField< ::gim::Message >*
      mutable_msgs();

  // @@protoc_insertion_point(class_scope:gim.GetPeerMessageResponse)
 private:
  inline void set_has_last_msgid();
  inline void clear_has_last_msgid();

  ::google::protobuf::int64 last_msgid_;
  ::google::protobuf::RepeatedPtrField< ::gim::Message > msgs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peer_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peer_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_peer_5fserver_2eproto();
  friend void protobuf_ShutdownFile_peer_5fserver_2eproto();

  void InitAsDefaultInstance();
  static GetPeerMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class SendPeerMessageRequest : public ::google::protobuf::MessageLite {
 public:
  SendPeerMessageRequest();
  virtual ~SendPeerMessageRequest();

  SendPeerMessageRequest(const SendPeerMessageRequest& from);

  inline SendPeerMessageRequest& operator=(const SendPeerMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const SendPeerMessageRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendPeerMessageRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendPeerMessageRequest* other);

  // implements Message ----------------------------------------------

  SendPeerMessageRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendPeerMessageRequest& from);
  void MergeFrom(const SendPeerMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gim.Message msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::gim::Message& msg() const;
  inline ::gim::Message* mutable_msg();
  inline ::gim::Message* release_msg();
  inline void set_allocated_msg(::gim::Message* msg);

  // @@protoc_insertion_point(class_scope:gim.SendPeerMessageRequest)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();

  ::gim::Message* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peer_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peer_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_peer_5fserver_2eproto();
  friend void protobuf_ShutdownFile_peer_5fserver_2eproto();

  void InitAsDefaultInstance();
  static SendPeerMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class SendPeerMessageResponse : public ::google::protobuf::MessageLite {
 public:
  SendPeerMessageResponse();
  virtual ~SendPeerMessageResponse();

  SendPeerMessageResponse(const SendPeerMessageResponse& from);

  inline SendPeerMessageResponse& operator=(const SendPeerMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const SendPeerMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendPeerMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SendPeerMessageResponse* other);

  // implements Message ----------------------------------------------

  SendPeerMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendPeerMessageResponse& from);
  void MergeFrom(const SendPeerMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gim.Message msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::gim::Message& msg() const;
  inline ::gim::Message* mutable_msg();
  inline ::gim::Message* release_msg();
  inline void set_allocated_msg(::gim::Message* msg);

  // @@protoc_insertion_point(class_scope:gim.SendPeerMessageResponse)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();

  ::gim::Message* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peer_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peer_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_peer_5fserver_2eproto();
  friend void protobuf_ShutdownFile_peer_5fserver_2eproto();

  void InitAsDefaultInstance();
  static SendPeerMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class RecvPeerMessageResponse : public ::google::protobuf::MessageLite {
 public:
  RecvPeerMessageResponse();
  virtual ~RecvPeerMessageResponse();

  RecvPeerMessageResponse(const RecvPeerMessageResponse& from);

  inline RecvPeerMessageResponse& operator=(const RecvPeerMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const RecvPeerMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RecvPeerMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RecvPeerMessageResponse* other);

  // implements Message ----------------------------------------------

  RecvPeerMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RecvPeerMessageResponse& from);
  void MergeFrom(const RecvPeerMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gim.Message msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::gim::Message& msg() const;
  inline ::gim::Message* mutable_msg();
  inline ::gim::Message* release_msg();
  inline void set_allocated_msg(::gim::Message* msg);

  // @@protoc_insertion_point(class_scope:gim.RecvPeerMessageResponse)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();

  ::gim::Message* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peer_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peer_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_peer_5fserver_2eproto();
  friend void protobuf_ShutdownFile_peer_5fserver_2eproto();

  void InitAsDefaultInstance();
  static RecvPeerMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushMessageRequest : public ::google::protobuf::MessageLite {
 public:
  PushMessageRequest();
  virtual ~PushMessageRequest();

  PushMessageRequest(const PushMessageRequest& from);

  inline PushMessageRequest& operator=(const PushMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const PushMessageRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushMessageRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushMessageRequest* other);

  // implements Message ----------------------------------------------

  PushMessageRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushMessageRequest& from);
  void MergeFrom(const PushMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sn = 1;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 1;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // required .gim.Message msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::gim::Message& msg() const;
  inline ::gim::Message* mutable_msg();
  inline ::gim::Message* release_msg();
  inline void set_allocated_msg(::gim::Message* msg);

  // @@protoc_insertion_point(class_scope:gim.PushMessageRequest)
 private:
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::std::string* sn_;
  ::gim::Message* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peer_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peer_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_peer_5fserver_2eproto();
  friend void protobuf_ShutdownFile_peer_5fserver_2eproto();

  void InitAsDefaultInstance();
  static PushMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class PushMessageResponse : public ::google::protobuf::MessageLite {
 public:
  PushMessageResponse();
  virtual ~PushMessageResponse();

  PushMessageResponse(const PushMessageResponse& from);

  inline PushMessageResponse& operator=(const PushMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const PushMessageResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushMessageResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushMessageResponse* other);

  // implements Message ----------------------------------------------

  PushMessageResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushMessageResponse& from);
  void MergeFrom(const PushMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sn = 1;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 1;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  inline ::std::string* release_sn();
  inline void set_allocated_sn(::std::string* sn);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gim.PushMessageResponse)
 private:
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string* sn_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peer_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peer_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_peer_5fserver_2eproto();
  friend void protobuf_ShutdownFile_peer_5fserver_2eproto();

  void InitAsDefaultInstance();
  static PushMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class PeerPacket : public ::google::protobuf::MessageLite {
 public:
  PeerPacket();
  virtual ~PeerPacket();

  PeerPacket(const PeerPacket& from);

  inline PeerPacket& operator=(const PeerPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const PeerPacket& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PeerPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PeerPacket* other);

  // implements Message ----------------------------------------------

  PeerPacket* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PeerPacket& from);
  void MergeFrom(const PeerPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);

  // optional .gim.GetPeerMessageRequest get_peer_msg_req = 2;
  inline bool has_get_peer_msg_req() const;
  inline void clear_get_peer_msg_req();
  static const int kGetPeerMsgReqFieldNumber = 2;
  inline const ::gim::GetPeerMessageRequest& get_peer_msg_req() const;
  inline ::gim::GetPeerMessageRequest* mutable_get_peer_msg_req();
  inline ::gim::GetPeerMessageRequest* release_get_peer_msg_req();
  inline void set_allocated_get_peer_msg_req(::gim::GetPeerMessageRequest* get_peer_msg_req);

  // optional .gim.GetPeerMessageResponse get_peer_msg_resp = 3;
  inline bool has_get_peer_msg_resp() const;
  inline void clear_get_peer_msg_resp();
  static const int kGetPeerMsgRespFieldNumber = 3;
  inline const ::gim::GetPeerMessageResponse& get_peer_msg_resp() const;
  inline ::gim::GetPeerMessageResponse* mutable_get_peer_msg_resp();
  inline ::gim::GetPeerMessageResponse* release_get_peer_msg_resp();
  inline void set_allocated_get_peer_msg_resp(::gim::GetPeerMessageResponse* get_peer_msg_resp);

  // optional .gim.SendPeerMessageRequest send_peer_msg_req = 4;
  inline bool has_send_peer_msg_req() const;
  inline void clear_send_peer_msg_req();
  static const int kSendPeerMsgReqFieldNumber = 4;
  inline const ::gim::SendPeerMessageRequest& send_peer_msg_req() const;
  inline ::gim::SendPeerMessageRequest* mutable_send_peer_msg_req();
  inline ::gim::SendPeerMessageRequest* release_send_peer_msg_req();
  inline void set_allocated_send_peer_msg_req(::gim::SendPeerMessageRequest* send_peer_msg_req);

  // optional .gim.SendPeerMessageResponse send_peer_msg_resp = 5;
  inline bool has_send_peer_msg_resp() const;
  inline void clear_send_peer_msg_resp();
  static const int kSendPeerMsgRespFieldNumber = 5;
  inline const ::gim::SendPeerMessageResponse& send_peer_msg_resp() const;
  inline ::gim::SendPeerMessageResponse* mutable_send_peer_msg_resp();
  inline ::gim::SendPeerMessageResponse* release_send_peer_msg_resp();
  inline void set_allocated_send_peer_msg_resp(::gim::SendPeerMessageResponse* send_peer_msg_resp);

  // optional .gim.RecvPeerMessageResponse recv_peer_msg_resp = 6;
  inline bool has_recv_peer_msg_resp() const;
  inline void clear_recv_peer_msg_resp();
  static const int kRecvPeerMsgRespFieldNumber = 6;
  inline const ::gim::RecvPeerMessageResponse& recv_peer_msg_resp() const;
  inline ::gim::RecvPeerMessageResponse* mutable_recv_peer_msg_resp();
  inline ::gim::RecvPeerMessageResponse* release_recv_peer_msg_resp();
  inline void set_allocated_recv_peer_msg_resp(::gim::RecvPeerMessageResponse* recv_peer_msg_resp);

  // @@protoc_insertion_point(class_scope:gim.PeerPacket)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_get_peer_msg_req();
  inline void clear_has_get_peer_msg_req();
  inline void set_has_get_peer_msg_resp();
  inline void clear_has_get_peer_msg_resp();
  inline void set_has_send_peer_msg_req();
  inline void clear_has_send_peer_msg_req();
  inline void set_has_send_peer_msg_resp();
  inline void clear_has_send_peer_msg_resp();
  inline void set_has_recv_peer_msg_resp();
  inline void clear_has_recv_peer_msg_resp();

  ::gim::GetPeerMessageRequest* get_peer_msg_req_;
  ::gim::GetPeerMessageResponse* get_peer_msg_resp_;
  ::gim::SendPeerMessageRequest* send_peer_msg_req_;
  ::gim::SendPeerMessageResponse* send_peer_msg_resp_;
  ::gim::RecvPeerMessageResponse* recv_peer_msg_resp_;
  ::google::protobuf::int32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_peer_5fserver_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_peer_5fserver_2eproto();
  #endif
  friend void protobuf_AssignDesc_peer_5fserver_2eproto();
  friend void protobuf_ShutdownFile_peer_5fserver_2eproto();

  void InitAsDefaultInstance();
  static PeerPacket* default_instance_;
};
// ===================================================================


// ===================================================================

// GetPeerMessageRequest

// optional string cid = 1;
inline bool GetPeerMessageRequest::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPeerMessageRequest::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPeerMessageRequest::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPeerMessageRequest::clear_cid() {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& GetPeerMessageRequest::cid() const {
  return *cid_;
}
inline void GetPeerMessageRequest::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GetPeerMessageRequest::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
}
inline void GetPeerMessageRequest::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPeerMessageRequest::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    cid_ = new ::std::string;
  }
  return cid_;
}
inline ::std::string* GetPeerMessageRequest::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetPeerMessageRequest::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::kEmptyString) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 start_msgid = 2;
inline bool GetPeerMessageRequest::has_start_msgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPeerMessageRequest::set_has_start_msgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPeerMessageRequest::clear_has_start_msgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPeerMessageRequest::clear_start_msgid() {
  start_msgid_ = GOOGLE_LONGLONG(0);
  clear_has_start_msgid();
}
inline ::google::protobuf::int64 GetPeerMessageRequest::start_msgid() const {
  return start_msgid_;
}
inline void GetPeerMessageRequest::set_start_msgid(::google::protobuf::int64 value) {
  set_has_start_msgid();
  start_msgid_ = value;
}

// optional int64 count = 3;
inline bool GetPeerMessageRequest::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPeerMessageRequest::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPeerMessageRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPeerMessageRequest::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::int64 GetPeerMessageRequest::count() const {
  return count_;
}
inline void GetPeerMessageRequest::set_count(::google::protobuf::int64 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// GetPeerMessageResponse

// optional int64 last_msgid = 1;
inline bool GetPeerMessageResponse::has_last_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPeerMessageResponse::set_has_last_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPeerMessageResponse::clear_has_last_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPeerMessageResponse::clear_last_msgid() {
  last_msgid_ = GOOGLE_LONGLONG(0);
  clear_has_last_msgid();
}
inline ::google::protobuf::int64 GetPeerMessageResponse::last_msgid() const {
  return last_msgid_;
}
inline void GetPeerMessageResponse::set_last_msgid(::google::protobuf::int64 value) {
  set_has_last_msgid();
  last_msgid_ = value;
}

// repeated .gim.Message msgs = 2;
inline int GetPeerMessageResponse::msgs_size() const {
  return msgs_.size();
}
inline void GetPeerMessageResponse::clear_msgs() {
  msgs_.Clear();
}
inline const ::gim::Message& GetPeerMessageResponse::msgs(int index) const {
  return msgs_.Get(index);
}
inline ::gim::Message* GetPeerMessageResponse::mutable_msgs(int index) {
  return msgs_.Mutable(index);
}
inline ::gim::Message* GetPeerMessageResponse::add_msgs() {
  return msgs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gim::Message >&
GetPeerMessageResponse::msgs() const {
  return msgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::gim::Message >*
GetPeerMessageResponse::mutable_msgs() {
  return &msgs_;
}

// -------------------------------------------------------------------

// SendPeerMessageRequest

// required .gim.Message msg = 1;
inline bool SendPeerMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendPeerMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendPeerMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendPeerMessageRequest::clear_msg() {
  if (msg_ != NULL) msg_->::gim::Message::Clear();
  clear_has_msg();
}
inline const ::gim::Message& SendPeerMessageRequest::msg() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_ != NULL ? *msg_ : *default_instance().msg_;
#else
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
#endif
}
inline ::gim::Message* SendPeerMessageRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::gim::Message;
  return msg_;
}
inline ::gim::Message* SendPeerMessageRequest::release_msg() {
  clear_has_msg();
  ::gim::Message* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void SendPeerMessageRequest::set_allocated_msg(::gim::Message* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// -------------------------------------------------------------------

// SendPeerMessageResponse

// required .gim.Message msg = 1;
inline bool SendPeerMessageResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendPeerMessageResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendPeerMessageResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendPeerMessageResponse::clear_msg() {
  if (msg_ != NULL) msg_->::gim::Message::Clear();
  clear_has_msg();
}
inline const ::gim::Message& SendPeerMessageResponse::msg() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_ != NULL ? *msg_ : *default_instance().msg_;
#else
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
#endif
}
inline ::gim::Message* SendPeerMessageResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::gim::Message;
  return msg_;
}
inline ::gim::Message* SendPeerMessageResponse::release_msg() {
  clear_has_msg();
  ::gim::Message* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void SendPeerMessageResponse::set_allocated_msg(::gim::Message* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// -------------------------------------------------------------------

// RecvPeerMessageResponse

// required .gim.Message msg = 1;
inline bool RecvPeerMessageResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecvPeerMessageResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecvPeerMessageResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecvPeerMessageResponse::clear_msg() {
  if (msg_ != NULL) msg_->::gim::Message::Clear();
  clear_has_msg();
}
inline const ::gim::Message& RecvPeerMessageResponse::msg() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_ != NULL ? *msg_ : *default_instance().msg_;
#else
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
#endif
}
inline ::gim::Message* RecvPeerMessageResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::gim::Message;
  return msg_;
}
inline ::gim::Message* RecvPeerMessageResponse::release_msg() {
  clear_has_msg();
  ::gim::Message* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void RecvPeerMessageResponse::set_allocated_msg(::gim::Message* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// -------------------------------------------------------------------

// PushMessageRequest

// required string sn = 1;
inline bool PushMessageRequest::has_sn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushMessageRequest::set_has_sn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushMessageRequest::clear_has_sn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushMessageRequest::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& PushMessageRequest::sn() const {
  return *sn_;
}
inline void PushMessageRequest::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void PushMessageRequest::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void PushMessageRequest::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushMessageRequest::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* PushMessageRequest::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PushMessageRequest::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .gim.Message msg = 2;
inline bool PushMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushMessageRequest::clear_msg() {
  if (msg_ != NULL) msg_->::gim::Message::Clear();
  clear_has_msg();
}
inline const ::gim::Message& PushMessageRequest::msg() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_ != NULL ? *msg_ : *default_instance().msg_;
#else
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
#endif
}
inline ::gim::Message* PushMessageRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::gim::Message;
  return msg_;
}
inline ::gim::Message* PushMessageRequest::release_msg() {
  clear_has_msg();
  ::gim::Message* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void PushMessageRequest::set_allocated_msg(::gim::Message* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// -------------------------------------------------------------------

// PushMessageResponse

// required string sn = 1;
inline bool PushMessageResponse::has_sn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushMessageResponse::set_has_sn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushMessageResponse::clear_has_sn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushMessageResponse::clear_sn() {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    sn_->clear();
  }
  clear_has_sn();
}
inline const ::std::string& PushMessageResponse::sn() const {
  return *sn_;
}
inline void PushMessageResponse::set_sn(const ::std::string& value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void PushMessageResponse::set_sn(const char* value) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void PushMessageResponse::set_sn(const char* value, size_t size) {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushMessageResponse::mutable_sn() {
  set_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    sn_ = new ::std::string;
  }
  return sn_;
}
inline ::std::string* PushMessageResponse::release_sn() {
  clear_has_sn();
  if (sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sn_;
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PushMessageResponse::set_allocated_sn(::std::string* sn) {
  if (sn_ != &::google::protobuf::internal::kEmptyString) {
    delete sn_;
  }
  if (sn) {
    set_has_sn();
    sn_ = sn;
  } else {
    clear_has_sn();
    sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 2;
inline bool PushMessageResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushMessageResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushMessageResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushMessageResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 PushMessageResponse::status() const {
  return status_;
}
inline void PushMessageResponse::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// PeerPacket

// required int32 cmd = 1;
inline bool PeerPacket::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeerPacket::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PeerPacket::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PeerPacket::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 PeerPacket::cmd() const {
  return cmd_;
}
inline void PeerPacket::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional .gim.GetPeerMessageRequest get_peer_msg_req = 2;
inline bool PeerPacket::has_get_peer_msg_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerPacket::set_has_get_peer_msg_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeerPacket::clear_has_get_peer_msg_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeerPacket::clear_get_peer_msg_req() {
  if (get_peer_msg_req_ != NULL) get_peer_msg_req_->::gim::GetPeerMessageRequest::Clear();
  clear_has_get_peer_msg_req();
}
inline const ::gim::GetPeerMessageRequest& PeerPacket::get_peer_msg_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return get_peer_msg_req_ != NULL ? *get_peer_msg_req_ : *default_instance().get_peer_msg_req_;
#else
  return get_peer_msg_req_ != NULL ? *get_peer_msg_req_ : *default_instance_->get_peer_msg_req_;
#endif
}
inline ::gim::GetPeerMessageRequest* PeerPacket::mutable_get_peer_msg_req() {
  set_has_get_peer_msg_req();
  if (get_peer_msg_req_ == NULL) get_peer_msg_req_ = new ::gim::GetPeerMessageRequest;
  return get_peer_msg_req_;
}
inline ::gim::GetPeerMessageRequest* PeerPacket::release_get_peer_msg_req() {
  clear_has_get_peer_msg_req();
  ::gim::GetPeerMessageRequest* temp = get_peer_msg_req_;
  get_peer_msg_req_ = NULL;
  return temp;
}
inline void PeerPacket::set_allocated_get_peer_msg_req(::gim::GetPeerMessageRequest* get_peer_msg_req) {
  delete get_peer_msg_req_;
  get_peer_msg_req_ = get_peer_msg_req;
  if (get_peer_msg_req) {
    set_has_get_peer_msg_req();
  } else {
    clear_has_get_peer_msg_req();
  }
}

// optional .gim.GetPeerMessageResponse get_peer_msg_resp = 3;
inline bool PeerPacket::has_get_peer_msg_resp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PeerPacket::set_has_get_peer_msg_resp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PeerPacket::clear_has_get_peer_msg_resp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PeerPacket::clear_get_peer_msg_resp() {
  if (get_peer_msg_resp_ != NULL) get_peer_msg_resp_->::gim::GetPeerMessageResponse::Clear();
  clear_has_get_peer_msg_resp();
}
inline const ::gim::GetPeerMessageResponse& PeerPacket::get_peer_msg_resp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return get_peer_msg_resp_ != NULL ? *get_peer_msg_resp_ : *default_instance().get_peer_msg_resp_;
#else
  return get_peer_msg_resp_ != NULL ? *get_peer_msg_resp_ : *default_instance_->get_peer_msg_resp_;
#endif
}
inline ::gim::GetPeerMessageResponse* PeerPacket::mutable_get_peer_msg_resp() {
  set_has_get_peer_msg_resp();
  if (get_peer_msg_resp_ == NULL) get_peer_msg_resp_ = new ::gim::GetPeerMessageResponse;
  return get_peer_msg_resp_;
}
inline ::gim::GetPeerMessageResponse* PeerPacket::release_get_peer_msg_resp() {
  clear_has_get_peer_msg_resp();
  ::gim::GetPeerMessageResponse* temp = get_peer_msg_resp_;
  get_peer_msg_resp_ = NULL;
  return temp;
}
inline void PeerPacket::set_allocated_get_peer_msg_resp(::gim::GetPeerMessageResponse* get_peer_msg_resp) {
  delete get_peer_msg_resp_;
  get_peer_msg_resp_ = get_peer_msg_resp;
  if (get_peer_msg_resp) {
    set_has_get_peer_msg_resp();
  } else {
    clear_has_get_peer_msg_resp();
  }
}

// optional .gim.SendPeerMessageRequest send_peer_msg_req = 4;
inline bool PeerPacket::has_send_peer_msg_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PeerPacket::set_has_send_peer_msg_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PeerPacket::clear_has_send_peer_msg_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PeerPacket::clear_send_peer_msg_req() {
  if (send_peer_msg_req_ != NULL) send_peer_msg_req_->::gim::SendPeerMessageRequest::Clear();
  clear_has_send_peer_msg_req();
}
inline const ::gim::SendPeerMessageRequest& PeerPacket::send_peer_msg_req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return send_peer_msg_req_ != NULL ? *send_peer_msg_req_ : *default_instance().send_peer_msg_req_;
#else
  return send_peer_msg_req_ != NULL ? *send_peer_msg_req_ : *default_instance_->send_peer_msg_req_;
#endif
}
inline ::gim::SendPeerMessageRequest* PeerPacket::mutable_send_peer_msg_req() {
  set_has_send_peer_msg_req();
  if (send_peer_msg_req_ == NULL) send_peer_msg_req_ = new ::gim::SendPeerMessageRequest;
  return send_peer_msg_req_;
}
inline ::gim::SendPeerMessageRequest* PeerPacket::release_send_peer_msg_req() {
  clear_has_send_peer_msg_req();
  ::gim::SendPeerMessageRequest* temp = send_peer_msg_req_;
  send_peer_msg_req_ = NULL;
  return temp;
}
inline void PeerPacket::set_allocated_send_peer_msg_req(::gim::SendPeerMessageRequest* send_peer_msg_req) {
  delete send_peer_msg_req_;
  send_peer_msg_req_ = send_peer_msg_req;
  if (send_peer_msg_req) {
    set_has_send_peer_msg_req();
  } else {
    clear_has_send_peer_msg_req();
  }
}

// optional .gim.SendPeerMessageResponse send_peer_msg_resp = 5;
inline bool PeerPacket::has_send_peer_msg_resp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PeerPacket::set_has_send_peer_msg_resp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PeerPacket::clear_has_send_peer_msg_resp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PeerPacket::clear_send_peer_msg_resp() {
  if (send_peer_msg_resp_ != NULL) send_peer_msg_resp_->::gim::SendPeerMessageResponse::Clear();
  clear_has_send_peer_msg_resp();
}
inline const ::gim::SendPeerMessageResponse& PeerPacket::send_peer_msg_resp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return send_peer_msg_resp_ != NULL ? *send_peer_msg_resp_ : *default_instance().send_peer_msg_resp_;
#else
  return send_peer_msg_resp_ != NULL ? *send_peer_msg_resp_ : *default_instance_->send_peer_msg_resp_;
#endif
}
inline ::gim::SendPeerMessageResponse* PeerPacket::mutable_send_peer_msg_resp() {
  set_has_send_peer_msg_resp();
  if (send_peer_msg_resp_ == NULL) send_peer_msg_resp_ = new ::gim::SendPeerMessageResponse;
  return send_peer_msg_resp_;
}
inline ::gim::SendPeerMessageResponse* PeerPacket::release_send_peer_msg_resp() {
  clear_has_send_peer_msg_resp();
  ::gim::SendPeerMessageResponse* temp = send_peer_msg_resp_;
  send_peer_msg_resp_ = NULL;
  return temp;
}
inline void PeerPacket::set_allocated_send_peer_msg_resp(::gim::SendPeerMessageResponse* send_peer_msg_resp) {
  delete send_peer_msg_resp_;
  send_peer_msg_resp_ = send_peer_msg_resp;
  if (send_peer_msg_resp) {
    set_has_send_peer_msg_resp();
  } else {
    clear_has_send_peer_msg_resp();
  }
}

// optional .gim.RecvPeerMessageResponse recv_peer_msg_resp = 6;
inline bool PeerPacket::has_recv_peer_msg_resp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PeerPacket::set_has_recv_peer_msg_resp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PeerPacket::clear_has_recv_peer_msg_resp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PeerPacket::clear_recv_peer_msg_resp() {
  if (recv_peer_msg_resp_ != NULL) recv_peer_msg_resp_->::gim::RecvPeerMessageResponse::Clear();
  clear_has_recv_peer_msg_resp();
}
inline const ::gim::RecvPeerMessageResponse& PeerPacket::recv_peer_msg_resp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return recv_peer_msg_resp_ != NULL ? *recv_peer_msg_resp_ : *default_instance().recv_peer_msg_resp_;
#else
  return recv_peer_msg_resp_ != NULL ? *recv_peer_msg_resp_ : *default_instance_->recv_peer_msg_resp_;
#endif
}
inline ::gim::RecvPeerMessageResponse* PeerPacket::mutable_recv_peer_msg_resp() {
  set_has_recv_peer_msg_resp();
  if (recv_peer_msg_resp_ == NULL) recv_peer_msg_resp_ = new ::gim::RecvPeerMessageResponse;
  return recv_peer_msg_resp_;
}
inline ::gim::RecvPeerMessageResponse* PeerPacket::release_recv_peer_msg_resp() {
  clear_has_recv_peer_msg_resp();
  ::gim::RecvPeerMessageResponse* temp = recv_peer_msg_resp_;
  recv_peer_msg_resp_ = NULL;
  return temp;
}
inline void PeerPacket::set_allocated_recv_peer_msg_resp(::gim::RecvPeerMessageResponse* recv_peer_msg_resp) {
  delete recv_peer_msg_resp_;
  recv_peer_msg_resp_ = recv_peer_msg_resp;
  if (recv_peer_msg_resp) {
    set_has_recv_peer_msg_resp();
  } else {
    clear_has_recv_peer_msg_resp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gim

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_peer_5fserver_2eproto__INCLUDED
