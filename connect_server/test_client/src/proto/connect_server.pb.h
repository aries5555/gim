// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: connect_server.proto

#ifndef PROTOBUF_connect_5fserver_2eproto__INCLUDED
#define PROTOBUF_connect_5fserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "pair.pb.h"
// @@protoc_insertion_point(includes)

namespace gim {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_connect_5fserver_2eproto();
void protobuf_AssignDesc_connect_5fserver_2eproto();
void protobuf_ShutdownFile_connect_5fserver_2eproto();

class LoginRequest;
class LoginResponse;
class Address;
class RedirectResponse;
class ServiceRequest;
class ServiceResponse;
class KickCliRequest;

// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();
  
  LoginRequest(const LoginRequest& from);
  
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();
  
  void Swap(LoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  
  // optional string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  
  // repeated .gim.Pair kvs = 5;
  inline int kvs_size() const;
  inline void clear_kvs();
  static const int kKvsFieldNumber = 5;
  inline const ::gim::Pair& kvs(int index) const;
  inline ::gim::Pair* mutable_kvs(int index);
  inline ::gim::Pair* add_kvs();
  inline const ::google::protobuf::RepeatedPtrField< ::gim::Pair >&
      kvs() const;
  inline ::google::protobuf::RepeatedPtrField< ::gim::Pair >*
      mutable_kvs();
  
  // @@protoc_insertion_point(class_scope:gim.LoginRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::google::protobuf::int32 type_;
  ::std::string* version_;
  static const ::std::string _default_version_;
  ::std::string* token_;
  static const ::std::string _default_token_;
  ::google::protobuf::RepeatedPtrField< ::gim::Pair > kvs_;
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();
  
  LoginResponse(const LoginResponse& from);
  
  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();
  
  void Swap(LoginResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional string sessid = 2;
  inline bool has_sessid() const;
  inline void clear_sessid();
  static const int kSessidFieldNumber = 2;
  inline const ::std::string& sessid() const;
  inline void set_sessid(const ::std::string& value);
  inline void set_sessid(const char* value);
  inline void set_sessid(const char* value, size_t size);
  inline ::std::string* mutable_sessid();
  
  // optional int64 server_time = 3;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 3;
  inline ::google::protobuf::int64 server_time() const;
  inline void set_server_time(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:gim.LoginResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 status_;
  ::std::string* sessid_;
  static const ::std::string _default_sessid_;
  ::google::protobuf::int64 server_time_;
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();
  
  Address(const Address& from);
  
  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();
  
  void Swap(Address* other);
  
  // implements Message ----------------------------------------------
  
  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  
  // optional int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:gim.Address)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* ip_;
  static const ::std::string _default_ip_;
  ::google::protobuf::int32 port_;
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class RedirectResponse : public ::google::protobuf::Message {
 public:
  RedirectResponse();
  virtual ~RedirectResponse();
  
  RedirectResponse(const RedirectResponse& from);
  
  inline RedirectResponse& operator=(const RedirectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedirectResponse& default_instance();
  
  void Swap(RedirectResponse* other);
  
  // implements Message ----------------------------------------------
  
  RedirectResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RedirectResponse& from);
  void MergeFrom(const RedirectResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // repeated .gim.Address addrs = 2;
  inline int addrs_size() const;
  inline void clear_addrs();
  static const int kAddrsFieldNumber = 2;
  inline const ::gim::Address& addrs(int index) const;
  inline ::gim::Address* mutable_addrs(int index);
  inline ::gim::Address* add_addrs();
  inline const ::google::protobuf::RepeatedPtrField< ::gim::Address >&
      addrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::gim::Address >*
      mutable_addrs();
  
  // @@protoc_insertion_point(class_scope:gim.RedirectResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 status_;
  ::google::protobuf::RepeatedPtrField< ::gim::Address > addrs_;
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RedirectResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServiceRequest : public ::google::protobuf::Message {
 public:
  ServiceRequest();
  virtual ~ServiceRequest();
  
  ServiceRequest(const ServiceRequest& from);
  
  inline ServiceRequest& operator=(const ServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceRequest& default_instance();
  
  void Swap(ServiceRequest* other);
  
  // implements Message ----------------------------------------------
  
  ServiceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceRequest& from);
  void MergeFrom(const ServiceRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string from_sessid = 1;
  inline bool has_from_sessid() const;
  inline void clear_from_sessid();
  static const int kFromSessidFieldNumber = 1;
  inline const ::std::string& from_sessid() const;
  inline void set_from_sessid(const ::std::string& value);
  inline void set_from_sessid(const char* value);
  inline void set_from_sessid(const char* value, size_t size);
  inline ::std::string* mutable_from_sessid();
  
  // optional string to_sessid = 2;
  inline bool has_to_sessid() const;
  inline void clear_to_sessid();
  static const int kToSessidFieldNumber = 2;
  inline const ::std::string& to_sessid() const;
  inline void set_to_sessid(const ::std::string& value);
  inline void set_to_sessid(const char* value);
  inline void set_to_sessid(const char* value, size_t size);
  inline ::std::string* mutable_to_sessid();
  
  // required int32 from_type = 3;
  inline bool has_from_type() const;
  inline void clear_from_type();
  static const int kFromTypeFieldNumber = 3;
  inline ::google::protobuf::int32 from_type() const;
  inline void set_from_type(::google::protobuf::int32 value);
  
  // required int32 to_type = 4;
  inline bool has_to_type() const;
  inline void clear_to_type();
  static const int kToTypeFieldNumber = 4;
  inline ::google::protobuf::int32 to_type() const;
  inline void set_to_type(::google::protobuf::int32 value);
  
  // required string sn = 5;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 5;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  
  // optional bytes payload = 6;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 6;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  
  // @@protoc_insertion_point(class_scope:gim.ServiceRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* from_sessid_;
  static const ::std::string _default_from_sessid_;
  ::std::string* to_sessid_;
  static const ::std::string _default_to_sessid_;
  ::google::protobuf::int32 from_type_;
  ::google::protobuf::int32 to_type_;
  ::std::string* sn_;
  static const ::std::string _default_sn_;
  ::std::string* payload_;
  static const ::std::string _default_payload_;
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ServiceRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServiceResponse : public ::google::protobuf::Message {
 public:
  ServiceResponse();
  virtual ~ServiceResponse();
  
  ServiceResponse(const ServiceResponse& from);
  
  inline ServiceResponse& operator=(const ServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceResponse& default_instance();
  
  void Swap(ServiceResponse* other);
  
  // implements Message ----------------------------------------------
  
  ServiceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceResponse& from);
  void MergeFrom(const ServiceResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string from_sessid = 1;
  inline bool has_from_sessid() const;
  inline void clear_from_sessid();
  static const int kFromSessidFieldNumber = 1;
  inline const ::std::string& from_sessid() const;
  inline void set_from_sessid(const ::std::string& value);
  inline void set_from_sessid(const char* value);
  inline void set_from_sessid(const char* value, size_t size);
  inline ::std::string* mutable_from_sessid();
  
  // optional string to_sessid = 2;
  inline bool has_to_sessid() const;
  inline void clear_to_sessid();
  static const int kToSessidFieldNumber = 2;
  inline const ::std::string& to_sessid() const;
  inline void set_to_sessid(const ::std::string& value);
  inline void set_to_sessid(const char* value);
  inline void set_to_sessid(const char* value, size_t size);
  inline ::std::string* mutable_to_sessid();
  
  // required int32 from_type = 3;
  inline bool has_from_type() const;
  inline void clear_from_type();
  static const int kFromTypeFieldNumber = 3;
  inline ::google::protobuf::int32 from_type() const;
  inline void set_from_type(::google::protobuf::int32 value);
  
  // required int32 to_type = 4;
  inline bool has_to_type() const;
  inline void clear_to_type();
  static const int kToTypeFieldNumber = 4;
  inline ::google::protobuf::int32 to_type() const;
  inline void set_to_type(::google::protobuf::int32 value);
  
  // required string sn = 5;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 5;
  inline const ::std::string& sn() const;
  inline void set_sn(const ::std::string& value);
  inline void set_sn(const char* value);
  inline void set_sn(const char* value, size_t size);
  inline ::std::string* mutable_sn();
  
  // required int32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional bytes payload = 7;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 7;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  
  // @@protoc_insertion_point(class_scope:gim.ServiceResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* from_sessid_;
  static const ::std::string _default_from_sessid_;
  ::std::string* to_sessid_;
  static const ::std::string _default_to_sessid_;
  ::google::protobuf::int32 from_type_;
  ::google::protobuf::int32 to_type_;
  ::std::string* sn_;
  static const ::std::string _default_sn_;
  ::google::protobuf::int32 status_;
  ::std::string* payload_;
  static const ::std::string _default_payload_;
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ServiceResponse* default_instance_;
};
// -------------------------------------------------------------------

class KickCliRequest : public ::google::protobuf::Message {
 public:
  KickCliRequest();
  virtual ~KickCliRequest();
  
  KickCliRequest(const KickCliRequest& from);
  
  inline KickCliRequest& operator=(const KickCliRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KickCliRequest& default_instance();
  
  void Swap(KickCliRequest* other);
  
  // implements Message ----------------------------------------------
  
  KickCliRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KickCliRequest& from);
  void MergeFrom(const KickCliRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string sessid = 1;
  inline bool has_sessid() const;
  inline void clear_sessid();
  static const int kSessidFieldNumber = 1;
  inline const ::std::string& sessid() const;
  inline void set_sessid(const ::std::string& value);
  inline void set_sessid(const char* value);
  inline void set_sessid(const char* value, size_t size);
  inline ::std::string* mutable_sessid();
  
  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional bytes reason = 4;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 4;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const void* value, size_t size);
  inline ::std::string* mutable_reason();
  
  // @@protoc_insertion_point(class_scope:gim.KickCliRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sessid_;
  static const ::std::string _default_sessid_;
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::google::protobuf::int32 type_;
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  friend void  protobuf_AddDesc_connect_5fserver_2eproto();
  friend void protobuf_AssignDesc_connect_5fserver_2eproto();
  friend void protobuf_ShutdownFile_connect_5fserver_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static KickCliRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// required string id = 1;
inline bool LoginRequest::has_id() const {
  return _has_bit(0);
}
inline void LoginRequest::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LoginRequest::id() const {
  return *id_;
}
inline void LoginRequest::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void LoginRequest::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void LoginRequest::set_id(const char* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional int32 type = 2;
inline bool LoginRequest::has_type() const {
  return _has_bit(1);
}
inline void LoginRequest::clear_type() {
  type_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 LoginRequest::type() const {
  return type_;
}
inline void LoginRequest::set_type(::google::protobuf::int32 value) {
  _set_bit(1);
  type_ = value;
}

// optional string version = 3;
inline bool LoginRequest::has_version() const {
  return _has_bit(2);
}
inline void LoginRequest::clear_version() {
  if (version_ != &_default_version_) {
    version_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& LoginRequest::version() const {
  return *version_;
}
inline void LoginRequest::set_version(const ::std::string& value) {
  _set_bit(2);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value) {
  _set_bit(2);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginRequest::set_version(const char* value, size_t size) {
  _set_bit(2);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_version() {
  _set_bit(2);
  if (version_ == &_default_version_) {
    version_ = new ::std::string;
  }
  return version_;
}

// optional string token = 4;
inline bool LoginRequest::has_token() const {
  return _has_bit(3);
}
inline void LoginRequest::clear_token() {
  if (token_ != &_default_token_) {
    token_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& LoginRequest::token() const {
  return *token_;
}
inline void LoginRequest::set_token(const ::std::string& value) {
  _set_bit(3);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value) {
  _set_bit(3);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginRequest::set_token(const char* value, size_t size) {
  _set_bit(3);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_token() {
  _set_bit(3);
  if (token_ == &_default_token_) {
    token_ = new ::std::string;
  }
  return token_;
}

// repeated .gim.Pair kvs = 5;
inline int LoginRequest::kvs_size() const {
  return kvs_.size();
}
inline void LoginRequest::clear_kvs() {
  kvs_.Clear();
}
inline const ::gim::Pair& LoginRequest::kvs(int index) const {
  return kvs_.Get(index);
}
inline ::gim::Pair* LoginRequest::mutable_kvs(int index) {
  return kvs_.Mutable(index);
}
inline ::gim::Pair* LoginRequest::add_kvs() {
  return kvs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gim::Pair >&
LoginRequest::kvs() const {
  return kvs_;
}
inline ::google::protobuf::RepeatedPtrField< ::gim::Pair >*
LoginRequest::mutable_kvs() {
  return &kvs_;
}

// -------------------------------------------------------------------

// LoginResponse

// required int32 status = 1;
inline bool LoginResponse::has_status() const {
  return _has_bit(0);
}
inline void LoginResponse::clear_status() {
  status_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 LoginResponse::status() const {
  return status_;
}
inline void LoginResponse::set_status(::google::protobuf::int32 value) {
  _set_bit(0);
  status_ = value;
}

// optional string sessid = 2;
inline bool LoginResponse::has_sessid() const {
  return _has_bit(1);
}
inline void LoginResponse::clear_sessid() {
  if (sessid_ != &_default_sessid_) {
    sessid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LoginResponse::sessid() const {
  return *sessid_;
}
inline void LoginResponse::set_sessid(const ::std::string& value) {
  _set_bit(1);
  if (sessid_ == &_default_sessid_) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value) {
  _set_bit(1);
  if (sessid_ == &_default_sessid_) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void LoginResponse::set_sessid(const char* value, size_t size) {
  _set_bit(1);
  if (sessid_ == &_default_sessid_) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_sessid() {
  _set_bit(1);
  if (sessid_ == &_default_sessid_) {
    sessid_ = new ::std::string;
  }
  return sessid_;
}

// optional int64 server_time = 3;
inline bool LoginResponse::has_server_time() const {
  return _has_bit(2);
}
inline void LoginResponse::clear_server_time() {
  server_time_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 LoginResponse::server_time() const {
  return server_time_;
}
inline void LoginResponse::set_server_time(::google::protobuf::int64 value) {
  _set_bit(2);
  server_time_ = value;
}

// -------------------------------------------------------------------

// Address

// optional string ip = 1;
inline bool Address::has_ip() const {
  return _has_bit(0);
}
inline void Address::clear_ip() {
  if (ip_ != &_default_ip_) {
    ip_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Address::ip() const {
  return *ip_;
}
inline void Address::set_ip(const ::std::string& value) {
  _set_bit(0);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Address::set_ip(const char* value) {
  _set_bit(0);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Address::set_ip(const char* value, size_t size) {
  _set_bit(0);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_ip() {
  _set_bit(0);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  return ip_;
}

// optional int32 port = 2;
inline bool Address::has_port() const {
  return _has_bit(1);
}
inline void Address::clear_port() {
  port_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Address::port() const {
  return port_;
}
inline void Address::set_port(::google::protobuf::int32 value) {
  _set_bit(1);
  port_ = value;
}

// -------------------------------------------------------------------

// RedirectResponse

// required int32 status = 1;
inline bool RedirectResponse::has_status() const {
  return _has_bit(0);
}
inline void RedirectResponse::clear_status() {
  status_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 RedirectResponse::status() const {
  return status_;
}
inline void RedirectResponse::set_status(::google::protobuf::int32 value) {
  _set_bit(0);
  status_ = value;
}

// repeated .gim.Address addrs = 2;
inline int RedirectResponse::addrs_size() const {
  return addrs_.size();
}
inline void RedirectResponse::clear_addrs() {
  addrs_.Clear();
}
inline const ::gim::Address& RedirectResponse::addrs(int index) const {
  return addrs_.Get(index);
}
inline ::gim::Address* RedirectResponse::mutable_addrs(int index) {
  return addrs_.Mutable(index);
}
inline ::gim::Address* RedirectResponse::add_addrs() {
  return addrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gim::Address >&
RedirectResponse::addrs() const {
  return addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::gim::Address >*
RedirectResponse::mutable_addrs() {
  return &addrs_;
}

// -------------------------------------------------------------------

// ServiceRequest

// optional string from_sessid = 1;
inline bool ServiceRequest::has_from_sessid() const {
  return _has_bit(0);
}
inline void ServiceRequest::clear_from_sessid() {
  if (from_sessid_ != &_default_from_sessid_) {
    from_sessid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ServiceRequest::from_sessid() const {
  return *from_sessid_;
}
inline void ServiceRequest::set_from_sessid(const ::std::string& value) {
  _set_bit(0);
  if (from_sessid_ == &_default_from_sessid_) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void ServiceRequest::set_from_sessid(const char* value) {
  _set_bit(0);
  if (from_sessid_ == &_default_from_sessid_) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void ServiceRequest::set_from_sessid(const char* value, size_t size) {
  _set_bit(0);
  if (from_sessid_ == &_default_from_sessid_) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_from_sessid() {
  _set_bit(0);
  if (from_sessid_ == &_default_from_sessid_) {
    from_sessid_ = new ::std::string;
  }
  return from_sessid_;
}

// optional string to_sessid = 2;
inline bool ServiceRequest::has_to_sessid() const {
  return _has_bit(1);
}
inline void ServiceRequest::clear_to_sessid() {
  if (to_sessid_ != &_default_to_sessid_) {
    to_sessid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ServiceRequest::to_sessid() const {
  return *to_sessid_;
}
inline void ServiceRequest::set_to_sessid(const ::std::string& value) {
  _set_bit(1);
  if (to_sessid_ == &_default_to_sessid_) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void ServiceRequest::set_to_sessid(const char* value) {
  _set_bit(1);
  if (to_sessid_ == &_default_to_sessid_) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void ServiceRequest::set_to_sessid(const char* value, size_t size) {
  _set_bit(1);
  if (to_sessid_ == &_default_to_sessid_) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_to_sessid() {
  _set_bit(1);
  if (to_sessid_ == &_default_to_sessid_) {
    to_sessid_ = new ::std::string;
  }
  return to_sessid_;
}

// required int32 from_type = 3;
inline bool ServiceRequest::has_from_type() const {
  return _has_bit(2);
}
inline void ServiceRequest::clear_from_type() {
  from_type_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 ServiceRequest::from_type() const {
  return from_type_;
}
inline void ServiceRequest::set_from_type(::google::protobuf::int32 value) {
  _set_bit(2);
  from_type_ = value;
}

// required int32 to_type = 4;
inline bool ServiceRequest::has_to_type() const {
  return _has_bit(3);
}
inline void ServiceRequest::clear_to_type() {
  to_type_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 ServiceRequest::to_type() const {
  return to_type_;
}
inline void ServiceRequest::set_to_type(::google::protobuf::int32 value) {
  _set_bit(3);
  to_type_ = value;
}

// required string sn = 5;
inline bool ServiceRequest::has_sn() const {
  return _has_bit(4);
}
inline void ServiceRequest::clear_sn() {
  if (sn_ != &_default_sn_) {
    sn_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& ServiceRequest::sn() const {
  return *sn_;
}
inline void ServiceRequest::set_sn(const ::std::string& value) {
  _set_bit(4);
  if (sn_ == &_default_sn_) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceRequest::set_sn(const char* value) {
  _set_bit(4);
  if (sn_ == &_default_sn_) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceRequest::set_sn(const char* value, size_t size) {
  _set_bit(4);
  if (sn_ == &_default_sn_) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_sn() {
  _set_bit(4);
  if (sn_ == &_default_sn_) {
    sn_ = new ::std::string;
  }
  return sn_;
}

// optional bytes payload = 6;
inline bool ServiceRequest::has_payload() const {
  return _has_bit(5);
}
inline void ServiceRequest::clear_payload() {
  if (payload_ != &_default_payload_) {
    payload_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& ServiceRequest::payload() const {
  return *payload_;
}
inline void ServiceRequest::set_payload(const ::std::string& value) {
  _set_bit(5);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceRequest::set_payload(const char* value) {
  _set_bit(5);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceRequest::set_payload(const void* value, size_t size) {
  _set_bit(5);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceRequest::mutable_payload() {
  _set_bit(5);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  return payload_;
}

// -------------------------------------------------------------------

// ServiceResponse

// optional string from_sessid = 1;
inline bool ServiceResponse::has_from_sessid() const {
  return _has_bit(0);
}
inline void ServiceResponse::clear_from_sessid() {
  if (from_sessid_ != &_default_from_sessid_) {
    from_sessid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ServiceResponse::from_sessid() const {
  return *from_sessid_;
}
inline void ServiceResponse::set_from_sessid(const ::std::string& value) {
  _set_bit(0);
  if (from_sessid_ == &_default_from_sessid_) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void ServiceResponse::set_from_sessid(const char* value) {
  _set_bit(0);
  if (from_sessid_ == &_default_from_sessid_) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(value);
}
inline void ServiceResponse::set_from_sessid(const char* value, size_t size) {
  _set_bit(0);
  if (from_sessid_ == &_default_from_sessid_) {
    from_sessid_ = new ::std::string;
  }
  from_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_from_sessid() {
  _set_bit(0);
  if (from_sessid_ == &_default_from_sessid_) {
    from_sessid_ = new ::std::string;
  }
  return from_sessid_;
}

// optional string to_sessid = 2;
inline bool ServiceResponse::has_to_sessid() const {
  return _has_bit(1);
}
inline void ServiceResponse::clear_to_sessid() {
  if (to_sessid_ != &_default_to_sessid_) {
    to_sessid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ServiceResponse::to_sessid() const {
  return *to_sessid_;
}
inline void ServiceResponse::set_to_sessid(const ::std::string& value) {
  _set_bit(1);
  if (to_sessid_ == &_default_to_sessid_) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void ServiceResponse::set_to_sessid(const char* value) {
  _set_bit(1);
  if (to_sessid_ == &_default_to_sessid_) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(value);
}
inline void ServiceResponse::set_to_sessid(const char* value, size_t size) {
  _set_bit(1);
  if (to_sessid_ == &_default_to_sessid_) {
    to_sessid_ = new ::std::string;
  }
  to_sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_to_sessid() {
  _set_bit(1);
  if (to_sessid_ == &_default_to_sessid_) {
    to_sessid_ = new ::std::string;
  }
  return to_sessid_;
}

// required int32 from_type = 3;
inline bool ServiceResponse::has_from_type() const {
  return _has_bit(2);
}
inline void ServiceResponse::clear_from_type() {
  from_type_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 ServiceResponse::from_type() const {
  return from_type_;
}
inline void ServiceResponse::set_from_type(::google::protobuf::int32 value) {
  _set_bit(2);
  from_type_ = value;
}

// required int32 to_type = 4;
inline bool ServiceResponse::has_to_type() const {
  return _has_bit(3);
}
inline void ServiceResponse::clear_to_type() {
  to_type_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 ServiceResponse::to_type() const {
  return to_type_;
}
inline void ServiceResponse::set_to_type(::google::protobuf::int32 value) {
  _set_bit(3);
  to_type_ = value;
}

// required string sn = 5;
inline bool ServiceResponse::has_sn() const {
  return _has_bit(4);
}
inline void ServiceResponse::clear_sn() {
  if (sn_ != &_default_sn_) {
    sn_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& ServiceResponse::sn() const {
  return *sn_;
}
inline void ServiceResponse::set_sn(const ::std::string& value) {
  _set_bit(4);
  if (sn_ == &_default_sn_) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceResponse::set_sn(const char* value) {
  _set_bit(4);
  if (sn_ == &_default_sn_) {
    sn_ = new ::std::string;
  }
  sn_->assign(value);
}
inline void ServiceResponse::set_sn(const char* value, size_t size) {
  _set_bit(4);
  if (sn_ == &_default_sn_) {
    sn_ = new ::std::string;
  }
  sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_sn() {
  _set_bit(4);
  if (sn_ == &_default_sn_) {
    sn_ = new ::std::string;
  }
  return sn_;
}

// required int32 status = 6;
inline bool ServiceResponse::has_status() const {
  return _has_bit(5);
}
inline void ServiceResponse::clear_status() {
  status_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 ServiceResponse::status() const {
  return status_;
}
inline void ServiceResponse::set_status(::google::protobuf::int32 value) {
  _set_bit(5);
  status_ = value;
}

// optional bytes payload = 7;
inline bool ServiceResponse::has_payload() const {
  return _has_bit(6);
}
inline void ServiceResponse::clear_payload() {
  if (payload_ != &_default_payload_) {
    payload_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& ServiceResponse::payload() const {
  return *payload_;
}
inline void ServiceResponse::set_payload(const ::std::string& value) {
  _set_bit(6);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceResponse::set_payload(const char* value) {
  _set_bit(6);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void ServiceResponse::set_payload(const void* value, size_t size) {
  _set_bit(6);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceResponse::mutable_payload() {
  _set_bit(6);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  return payload_;
}

// -------------------------------------------------------------------

// KickCliRequest

// optional string sessid = 1;
inline bool KickCliRequest::has_sessid() const {
  return _has_bit(0);
}
inline void KickCliRequest::clear_sessid() {
  if (sessid_ != &_default_sessid_) {
    sessid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& KickCliRequest::sessid() const {
  return *sessid_;
}
inline void KickCliRequest::set_sessid(const ::std::string& value) {
  _set_bit(0);
  if (sessid_ == &_default_sessid_) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void KickCliRequest::set_sessid(const char* value) {
  _set_bit(0);
  if (sessid_ == &_default_sessid_) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(value);
}
inline void KickCliRequest::set_sessid(const char* value, size_t size) {
  _set_bit(0);
  if (sessid_ == &_default_sessid_) {
    sessid_ = new ::std::string;
  }
  sessid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KickCliRequest::mutable_sessid() {
  _set_bit(0);
  if (sessid_ == &_default_sessid_) {
    sessid_ = new ::std::string;
  }
  return sessid_;
}

// optional string id = 2;
inline bool KickCliRequest::has_id() const {
  return _has_bit(1);
}
inline void KickCliRequest::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& KickCliRequest::id() const {
  return *id_;
}
inline void KickCliRequest::set_id(const ::std::string& value) {
  _set_bit(1);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void KickCliRequest::set_id(const char* value) {
  _set_bit(1);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void KickCliRequest::set_id(const char* value, size_t size) {
  _set_bit(1);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KickCliRequest::mutable_id() {
  _set_bit(1);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional int32 type = 3;
inline bool KickCliRequest::has_type() const {
  return _has_bit(2);
}
inline void KickCliRequest::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 KickCliRequest::type() const {
  return type_;
}
inline void KickCliRequest::set_type(::google::protobuf::int32 value) {
  _set_bit(2);
  type_ = value;
}

// optional bytes reason = 4;
inline bool KickCliRequest::has_reason() const {
  return _has_bit(3);
}
inline void KickCliRequest::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& KickCliRequest::reason() const {
  return *reason_;
}
inline void KickCliRequest::set_reason(const ::std::string& value) {
  _set_bit(3);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void KickCliRequest::set_reason(const char* value) {
  _set_bit(3);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void KickCliRequest::set_reason(const void* value, size_t size) {
  _set_bit(3);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KickCliRequest::mutable_reason() {
  _set_bit(3);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gim

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_connect_5fserver_2eproto__INCLUDED
